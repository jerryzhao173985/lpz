Checking selforg/agent.cpp ...
selforg/agent.cpp:33:0: information: Include file: "abstractwiring.h" not found. [missingInclude]
#include "abstractwiring.h"
^
selforg/utils/configurable.h:138:5: warning: Member variable 'Configurable::parent' is not initialized in the constructor. [uninitMemberVar]
    Configurable()
    ^
selforg/utils/configurable.h:143:5: warning: Member variable 'Configurable::parent' is not initialized in the constructor. [uninitMemberVar]
    Configurable(const std::string& name, const std::string& revision) :
    ^
selforg/utils/trackrobots.h:68:3: warning: Member variable 'TrackRobot::enabledDuringVideo' is not initialized in the constructor. [uninitMemberVar]
  TrackRobot(TrackRobotConf conf = getDefaultConf())
  ^
selforg/utils/position.h:34:3: warning: Member variable 'Position::array' is not initialized in the constructor. [uninitMemberVar]
  Position(double _x, double _y, double _z){ x=_x; y=_y; z=_z; }
  ^
selforg/utils/position.h:36:3: warning: Member variable 'Position::array' is not initialized in the constructor. [uninitMemberVar]
  Position(const double* p){ x=p[0]; y=p[1]; z=p[2]; }
  ^
selforg/utils/trackrobots.h:104:5: performance: Variable 'conf' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    conf = getDefaultConf();
    ^
selforg/utils/plotoption.h:102:16: style: Virtual function 'setFilter' is called from constructor 'PlotOption(PlotMode mode,int interval=1,std::string parameter=std::string()' at line 90. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void setFilter(const std::string& filter);
               ^
selforg/utils/plotoption.h:90:7: note: Calling setFilter
      setFilter(filter);
      ^
selforg/utils/plotoption.h:102:16: note: setFilter is a virtual function
  virtual void setFilter(const std::string& filter);
               ^
selforg/utils/plotoption.h:86:3: style: Class 'PlotOption' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  PlotOption( PlotMode mode, int interval = 1, std::string parameter=std::string(), std::string filter=std::string())
  ^
selforg/utils/plotoption.h:112:5: style: Struct 'matchMode' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    matchMode(PlotMode mode) : mode(mode) {}
    ^
selforg/utils/plotoptionengine.h:41:3: style: Class 'PlotOptionEngine' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  PlotOptionEngine(const PlotOption& plotOption);
  ^
selforg/utils/plotoptionengine.h:42:3: style: Class 'PlotOptionEngine' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  PlotOptionEngine(const std::list<PlotOption>& plotOptions);
  ^
selforg/utils/stl_adds.h:95:5: style: Struct 'join' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    join(const T& delimit) : delimit(delimit), count(0) {}
    ^
selforg/utils/inspectable.h:107:3: style: Class 'Inspectable' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Inspectable(const iparamkey& name = "");
  ^
selforg/utils/inspectable.h:95:5: style: Struct 'matchName' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    matchName(std::string name) : name(name) {}
    ^
selforg/utils/configurable.h:127:9: style: Struct 'matchId' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        matchId(int id) :
        ^
selforg/wiredcontroller.h:63:3: style: Class 'WiredController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  WiredController(const PlotOption& plotOption = PlotOption(NoPlot), double noisefactor = 1, const iparamkey& name = "WiredController", const paramkey& revision = "$ID");
  ^
selforg/wiredcontroller.h:67:3: style: Class 'WiredController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  WiredController(const std::list<PlotOption>& plotOptions, double noisefactor = 1, const iparamkey& name = "WiredController", const paramkey& revision = "$ID");
  ^
selforg/utils/trackrobots.h:68:3: style: Class 'TrackRobot' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  TrackRobot(TrackRobotConf conf = getDefaultConf())
  ^
selforg/agent.h:57:3: style: Class 'Agent' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Agent(const PlotOption& plotOption = PlotOption(NoPlot), double noisefactor = 1, const iparamkey& name = "Agent", const paramkey& revision = "$ID");
  ^
selforg/agent.h:61:3: style: Class 'Agent' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Agent(const std::list<PlotOption>& plotOptions, double noisefactor = 1, const iparamkey& name = "Agent", const paramkey& revision = "$ID");
  ^
selforg/utils/position.h:36:3: style: Class 'Position' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Position(const double* p){ x=p[0]; y=p[1]; z=p[2]; }
  ^
selforg/utils/sensormotorinfo.h:38:3: style: Class 'SensorMotorInfo' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  SensorMotorInfo(std::string name=std::string())
  ^
selforg/utils/configurable.h:156:14: style: The destructor '~Configurable' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~Configurable()
             ^
selforg/utils/backcaller.h:54:14: note: Virtual destructor in base class
    virtual ~BackCaller();
             ^
selforg/utils/configurable.h:156:14: note: Destructor in derived class
    virtual ~Configurable()
             ^
selforg/wiredcontroller.h:71:12: style: The destructor '~WiredController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~WiredController();
           ^
selforg/utils/inspectable.h:110:12: note: Virtual destructor in base class
  virtual ~Inspectable();
           ^
selforg/wiredcontroller.h:71:12: note: Destructor in derived class
  virtual ~WiredController();
           ^
selforg/abstractrobot.h:55:12: style: The destructor '~AbstractRobot' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~AbstractRobot(){}
           ^
selforg/trackable.h:48:12: note: Virtual destructor in base class
  virtual ~Trackable() {};
           ^
selforg/abstractrobot.h:55:12: note: Destructor in derived class
  virtual ~AbstractRobot(){}
           ^
selforg/abstractrobot.h:78:23: style: The function 'getTrackableName' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::string getTrackableName() const {return getName();}
                      ^
selforg/trackable.h:52:23: note: Virtual function in base class
  virtual std::string getTrackableName() const = 0;
                      ^
selforg/abstractrobot.h:78:23: note: Function in derived class
  virtual std::string getTrackableName() const {return getName();}
                      ^
selforg/agent.cpp:71:19: style: C-style pointer casting [cstyleCast]
  rsensors      = (sensor*) malloc(sizeof(sensor) * rsensornumber);
                  ^
selforg/agent.cpp:72:19: style: C-style pointer casting [cstyleCast]
  rmotors       = (motor*)  malloc(sizeof(motor)  * rmotornumber);
                  ^
selforg/utils/trackrobots.h:68:29: performance: Function parameter 'conf' should be passed by const reference. However it seems that 'TrackRobot' is a callback function. [passedByValueCallback]
  TrackRobot(TrackRobotConf conf = getDefaultConf())
                            ^
selforg/utils/trackrobots.h:60:7: note: Function pointer used here.
class TrackRobot {
      ^
selforg/utils/trackrobots.h:68:29: note: Function parameter 'conf' should be passed by const reference. However it seems that 'TrackRobot' is a callback function.
  TrackRobot(TrackRobotConf conf = getDefaultConf())
                            ^
selforg/agent.cpp:123:21: style: Variable 'c' can be declared as pointer to const [constVariablePointer]
      Configurable* c = dynamic_cast<Configurable*>(wiring);
                    ^
selforg/utils/configurable.h:132:39: style: Parameter 'c' can be declared as pointer to const [constParameterPointer]
        bool operator()(Configurable* c)
                                      ^
selforg/utils/stl_adds.h:121:11: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
      res.push_back(fun(p));
          ^
1/142 files checked 0% done
Checking selforg/controller/abstractcontroller.cpp ...
selforg/controller/abstractcontroller.cpp:50:15: style: Variable 'i' can be declared as reference to const [constVariableReference]
    for(auto& i: sensorIndexMap){
              ^
selforg/controller/abstractcontroller.cpp:65:15: style: Variable 'i' can be declared as reference to const [constVariableReference]
    for(auto& i: motorIndexMap){
              ^
2/142 files checked 0% done
Checking selforg/controller/abstractiafcontroller.cpp ...
selforg/utils/noisegenerator.h:215:3: warning: Member variable 'ColorNormalNoise::factor' is not initialized in the constructor. [uninitMemberVar]
  ColorNormalNoise(double tau=0.05)
  ^
selforg/controller/abstractiafcontroller.cpp:25:24: warning: Member variable 'AbstractIAFController::randG' is not initialized in the constructor. [uninitMemberVar]
AbstractIAFController::AbstractIAFController(const AbstractIAFControllerConf& conf)
                       ^
selforg/controller/abstractiafcontroller.cpp:25:24: warning: Member variable 'AbstractIAFController::sensorNumber' is not initialized in the constructor. [uninitMemberVar]
AbstractIAFController::AbstractIAFController(const AbstractIAFControllerConf& conf)
                       ^
selforg/controller/abstractiafcontroller.cpp:25:24: warning: Member variable 'AbstractIAFController::motorNumber' is not initialized in the constructor. [uninitMemberVar]
AbstractIAFController::AbstractIAFController(const AbstractIAFControllerConf& conf)
                       ^
selforg/utils/noisegenerator.h:165:3: style: Class 'ColorUniformNoise' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  ColorUniformNoise(double tau=0.05)
  ^
selforg/utils/noisegenerator.h:215:3: style: Class 'ColorNormalNoise' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  ColorNormalNoise(double tau=0.05)
  ^
selforg/controller/abstractiafcontroller.h:72:3: style: Class 'AbstractIAFController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  AbstractIAFController(const AbstractIAFControllerConf& conf = getDefaultConf());
  ^
selforg/utils/noisegenerator.h:121:12: style: The destructor '~NoNoise' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~NoNoise(){}
           ^
selforg/utils/noisegenerator.h:46:12: note: Virtual destructor in base class
  virtual ~NoiseGenerator()
           ^
selforg/utils/noisegenerator.h:121:12: note: Destructor in derived class
  virtual ~NoNoise(){}
           ^
selforg/utils/noisegenerator.h:122:18: style: The function 'generate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:78:18: note: Virtual function in base class
  virtual double generate() = 0;
                 ^
selforg/utils/noisegenerator.h:122:18: note: Function in derived class
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:132:12: style: The destructor '~WhiteUniformNoise' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~WhiteUniformNoise(){}
           ^
selforg/utils/noisegenerator.h:46:12: note: Virtual destructor in base class
  virtual ~NoiseGenerator()
           ^
selforg/utils/noisegenerator.h:132:12: note: Destructor in derived class
  virtual ~WhiteUniformNoise(){}
           ^
selforg/utils/noisegenerator.h:133:18: style: The function 'generate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:78:18: note: Virtual function in base class
  virtual double generate() = 0;
                 ^
selforg/utils/noisegenerator.h:133:18: note: Function in derived class
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:144:12: style: The destructor '~WhiteNormalNoise' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~WhiteNormalNoise(){}
           ^
selforg/utils/noisegenerator.h:46:12: note: Virtual destructor in base class
  virtual ~NoiseGenerator()
           ^
selforg/utils/noisegenerator.h:144:12: note: Destructor in derived class
  virtual ~WhiteNormalNoise(){}
           ^
selforg/utils/noisegenerator.h:145:18: style: The function 'generate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:78:18: note: Virtual function in base class
  virtual double generate() = 0;
                 ^
selforg/utils/noisegenerator.h:145:18: note: Function in derived class
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:171:12: style: The destructor '~ColorUniformNoise' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~ColorUniformNoise(){ if(mean) free(mean);}
           ^
selforg/utils/noisegenerator.h:46:12: note: Virtual destructor in base class
  virtual ~NoiseGenerator()
           ^
selforg/utils/noisegenerator.h:171:12: note: Destructor in derived class
  virtual ~ColorUniformNoise(){ if(mean) free(mean);}
           ^
selforg/utils/noisegenerator.h:172:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int dimension, RandGen* randGen=0){
               ^
selforg/utils/noisegenerator.h:61:16: note: Virtual function in base class
  virtual void init(unsigned int dimension, RandGen* randGen=0)
               ^
selforg/utils/noisegenerator.h:172:16: note: Function in derived class
  virtual void init(unsigned int dimension, RandGen* randGen=0){
               ^
selforg/utils/noisegenerator.h:180:18: style: The function 'generate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:78:18: note: Virtual function in base class
  virtual double generate() = 0;
                 ^
selforg/utils/noisegenerator.h:180:18: note: Function in derived class
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:190:16: style: The function 'add' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void add(double *value, double noiseStrength){
               ^
selforg/utils/noisegenerator.h:85:16: note: Virtual function in base class
  virtual void add(double *value, double noiseStrength){
               ^
selforg/utils/noisegenerator.h:190:16: note: Function in derived class
  virtual void add(double *value, double noiseStrength){
               ^
selforg/utils/noisegenerator.h:222:12: style: The destructor '~ColorNormalNoise' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~ColorNormalNoise(){if(mean) free(mean);}
           ^
selforg/utils/noisegenerator.h:144:12: note: Virtual destructor in base class
  virtual ~WhiteNormalNoise(){}
           ^
selforg/utils/noisegenerator.h:222:12: note: Destructor in derived class
  virtual ~ColorNormalNoise(){if(mean) free(mean);}
           ^
selforg/utils/noisegenerator.h:224:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int dimension, RandGen* randGen=0){
               ^
selforg/utils/noisegenerator.h:61:16: note: Virtual function in base class
  virtual void init(unsigned int dimension, RandGen* randGen=0)
               ^
selforg/utils/noisegenerator.h:224:16: note: Function in derived class
  virtual void init(unsigned int dimension, RandGen* randGen=0){
               ^
selforg/utils/noisegenerator.h:232:18: style: The function 'generate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double generate() { //double stddev, double meanvalue) {
                 ^
selforg/utils/noisegenerator.h:145:18: note: Virtual function in base class
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:232:18: note: Function in derived class
  virtual double generate() { //double stddev, double meanvalue) {
                 ^
selforg/utils/noisegenerator.h:237:16: style: The function 'add' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void add(double *value, double noiseStrength) {
               ^
selforg/utils/noisegenerator.h:85:16: note: Virtual function in base class
  virtual void add(double *value, double noiseStrength){
               ^
selforg/utils/noisegenerator.h:237:16: note: Function in derived class
  virtual void add(double *value, double noiseStrength) {
               ^
selforg/utils/noisegenerator.h:275:12: style: The destructor '~SineWhiteNoise' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~SineWhiteNoise(){}
           ^
selforg/utils/noisegenerator.h:46:12: note: Virtual destructor in base class
  virtual ~NoiseGenerator()
           ^
selforg/utils/noisegenerator.h:275:12: note: Destructor in derived class
  virtual ~SineWhiteNoise(){}
           ^
selforg/utils/noisegenerator.h:277:18: style: The function 'generate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:78:18: note: Virtual function in base class
  virtual double generate() = 0;
                 ^
selforg/utils/noisegenerator.h:277:18: note: Function in derived class
  virtual double generate() {
                 ^
selforg/utils/noisegenerator.h:285:16: style: The function 'add' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void add(double *value, double noiseStrength) { // min, double max){
               ^
selforg/utils/noisegenerator.h:85:16: note: Virtual function in base class
  virtual void add(double *value, double noiseStrength){
               ^
selforg/utils/noisegenerator.h:285:16: note: Function in derived class
  virtual void add(double *value, double noiseStrength) { // min, double max){
               ^
selforg/controller/abstractiafcontroller.h:74:12: style: The destructor '~AbstractIAFController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~AbstractIAFController() {}
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/abstractiafcontroller.h:74:12: note: Destructor in derived class
  virtual ~AbstractIAFController() {}
           ^
selforg/controller/abstractiafcontroller.h:95:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/abstractiafcontroller.h:95:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractiafcontroller.h:97:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return sensorNumber; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/abstractiafcontroller.h:97:15: note: Function in derived class
  virtual int getSensorNumber() const { return sensorNumber; }
              ^
selforg/controller/abstractiafcontroller.h:99:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const { return motorNumber; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/abstractiafcontroller.h:99:15: note: Function in derived class
  virtual int getMotorNumber() const { return motorNumber; }
              ^
selforg/controller/abstractiafcontroller.h:101:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber, motor* motors, int motornumber);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractiafcontroller.h:101:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber, motor* motors, int motornumber);
               ^
selforg/controller/abstractiafcontroller.h:103:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* sensors, int sensornumber, motor* motors, int motornumber);
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractiafcontroller.h:103:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* sensors, int sensornumber, motor* motors, int motornumber);
               ^
selforg/controller/abstractiafcontroller.h:107:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const { return true; }
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/abstractiafcontroller.h:107:16: note: Function in derived class
  virtual bool store(FILE* f) const { return true; }
               ^
selforg/controller/abstractiafcontroller.h:109:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f) { return true; }
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/abstractiafcontroller.h:109:16: note: Function in derived class
  virtual bool restore(FILE* f) { return true; }
               ^
selforg/controller/abstractiafcontroller.h:48:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::numberIAFNeuronsPerInput' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* numberIAFNeuronsPerInput;  ///< simulate a population if >1
                          ^
selforg/controller/abstractiafcontroller.h:49:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::numberIAFNeuronsPerOutput' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* numberIAFNeuronsPerOutput; ///< simulate a population if >1
                          ^
selforg/controller/abstractiafcontroller.h:50:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::wIInitScale' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* wIInitScale;            ///< scaling factor of weights, initialized random
                          ^
selforg/controller/abstractiafcontroller.h:51:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::wOInitScale' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* wOInitScale;            ///< between [-1*wInitScale,1*wInitScale]
                          ^
selforg/controller/abstractiafcontroller.h:52:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::thresholdI' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* thresholdI;
                          ^
selforg/controller/abstractiafcontroller.h:53:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::thresholdO' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* thresholdO;
                          ^
selforg/controller/abstractiafcontroller.h:54:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::leakI' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* leakI;
                          ^
selforg/controller/abstractiafcontroller.h:55:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::leakO' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* leakO;
                          ^
selforg/controller/abstractiafcontroller.h:56:27: style: Class 'AbstractIAFControllerConf' is unsafe, 'AbstractIAFControllerConf::restingPotential' can leak by wrong usage. [unsafeClassCanLeak]
  Configurable::paramval* restingPotential;
                          ^
selforg/utils/noisegenerator.h:176:9: warning: If memory allocation fails, then there is a possible null pointer dereference: mean [nullPointerOutOfMemory]
        mean[i]=0.0;
        ^
selforg/utils/noisegenerator.h:174:27: note: Assuming allocation function fails
    mean = (double*)malloc(sizeof(double) * dimension);
                          ^
selforg/utils/noisegenerator.h:174:12: note: Assignment 'mean=(double*)malloc(sizeof(double)*dimension)', assigned value is 0
    mean = (double*)malloc(sizeof(double) * dimension);
           ^
selforg/utils/noisegenerator.h:176:9: note: Null pointer dereference
        mean[i]=0.0;
        ^
selforg/utils/noisegenerator.h:228:9: warning: If memory allocation fails, then there is a possible null pointer dereference: mean [nullPointerOutOfMemory]
        mean[i]=0.0;
        ^
selforg/utils/noisegenerator.h:226:27: note: Assuming allocation function fails
    mean = (double*)malloc(sizeof(double) * dimension);
                          ^
selforg/utils/noisegenerator.h:226:12: note: Assignment 'mean=(double*)malloc(sizeof(double)*dimension)', assigned value is 0
    mean = (double*)malloc(sizeof(double) * dimension);
           ^
selforg/utils/noisegenerator.h:228:9: note: Null pointer dereference
        mean[i]=0.0;
        ^
selforg/utils/noisegenerator.h:174:12: style: C-style pointer casting [cstyleCast]
    mean = (double*)malloc(sizeof(double) * dimension);
           ^
selforg/utils/noisegenerator.h:226:12: style: C-style pointer casting [cstyleCast]
    mean = (double*)malloc(sizeof(double) * dimension);
           ^
selforg/controller/abstractiafcontroller.h:32:16: style: C-style pointer casting [cstyleCast]
    thresholdI=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
               ^
selforg/controller/abstractiafcontroller.h:33:16: style: C-style pointer casting [cstyleCast]
    thresholdO=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
               ^
selforg/controller/abstractiafcontroller.h:34:11: style: C-style pointer casting [cstyleCast]
    leakI=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
          ^
selforg/controller/abstractiafcontroller.h:35:11: style: C-style pointer casting [cstyleCast]
    leakO=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
          ^
selforg/controller/abstractiafcontroller.h:36:22: style: C-style pointer casting [cstyleCast]
    restingPotential=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
                     ^
selforg/controller/abstractiafcontroller.h:37:17: style: C-style pointer casting [cstyleCast]
    wIInitScale=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
                ^
selforg/controller/abstractiafcontroller.h:38:17: style: C-style pointer casting [cstyleCast]
    wOInitScale=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
                ^
selforg/controller/abstractiafcontroller.h:39:30: style: C-style pointer casting [cstyleCast]
    numberIAFNeuronsPerInput=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
                             ^
selforg/controller/abstractiafcontroller.h:40:31: style: C-style pointer casting [cstyleCast]
    numberIAFNeuronsPerOutput=(Configurable::paramval*) malloc(sizeof(Configurable::paramval));
                              ^
selforg/controller/abstractiafcontroller.h:148:19: style: C-style pointer casting [cstyleCast]
    RandGen* g = (RandGen*) r;
                  ^
selforg/controller/abstractiafcontroller.h:164:20: style: C-style pointer casting [cstyleCast]
    double damp = *(double*)r;
                   ^
selforg/controller/abstractiafcontroller.h:175:21: style: C-style pointer casting [cstyleCast]
    double value = *(double*)r;
                    ^
selforg/controller/abstractiafcontroller.h:182:19: style: C-style pointer casting [cstyleCast]
    RandGen* g = (RandGen*) r;
                  ^
3/142 files checked 1% done
Checking selforg/controller/abstractmulticontroller.cpp ...
selforg/controller/abstractcontrolleradapter.h:63:12: style: The destructor '~AbstractControllerAdapter' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~AbstractControllerAdapter() {}
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/abstractcontrolleradapter.h:63:12: note: Destructor in derived class
  virtual ~AbstractControllerAdapter() {}
           ^
selforg/controller/abstractcontrolleradapter.h:80:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0){
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/abstractcontrolleradapter.h:80:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0){
               ^
selforg/controller/abstractcontrolleradapter.h:86:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return controller->getSensorNumber();}
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/abstractcontrolleradapter.h:86:15: note: Function in derived class
  virtual int getSensorNumber() const { return controller->getSensorNumber();}
              ^
selforg/controller/abstractcontrolleradapter.h:90:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const {  return controller->getMotorNumber();}
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/abstractcontrolleradapter.h:90:15: note: Function in derived class
  virtual int getMotorNumber() const {  return controller->getMotorNumber();}
              ^
selforg/controller/abstractcontrolleradapter.h:99:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontrolleradapter.h:99:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontrolleradapter.h:107:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontrolleradapter.h:107:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/abstractcontrolleradapter.h:142:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const {
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/abstractcontrolleradapter.h:142:16: note: Function in derived class
  virtual bool store(FILE* f) const {
               ^
selforg/controller/abstractcontrolleradapter.h:147:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f) {
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/abstractcontrolleradapter.h:147:16: note: Function in derived class
  virtual bool restore(FILE* f) {
               ^
selforg/controller/abstractmulticontroller.h:47:18: style: The destructor '~AbstractMultiController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual ~AbstractMultiController();
                 ^
selforg/controller/abstractcontrolleradapter.h:63:12: note: Virtual destructor in base class
  virtual ~AbstractControllerAdapter() {}
           ^
selforg/controller/abstractmulticontroller.h:47:18: note: Destructor in derived class
        virtual ~AbstractMultiController();
                 ^
selforg/controller/abstractmulticontroller.h:77:22: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
                     ^
selforg/controller/abstractcontrolleradapter.h:80:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0){
               ^
selforg/controller/abstractmulticontroller.h:77:22: note: Function in derived class
        virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
                     ^
selforg/controller/abstractmulticontroller.h:86:22: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void step(const sensor* sensors, int sensornumber,
                     ^
selforg/controller/abstractcontrolleradapter.h:99:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractmulticontroller.h:86:22: note: Function in derived class
        virtual void step(const sensor* sensors, int sensornumber,
                     ^
selforg/controller/abstractmulticontroller.h:92:22: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void stepNoLearning(const sensor* sensors , int sensornumber,
                     ^
selforg/controller/abstractcontrolleradapter.h:107:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/abstractmulticontroller.h:92:22: note: Function in derived class
        virtual void stepNoLearning(const sensor* sensors , int sensornumber,
                     ^
selforg/controller/abstractmulticontroller.h:127:22: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual bool store(FILE* f) const;
                     ^
selforg/controller/abstractcontrolleradapter.h:142:16: note: Virtual function in base class
  virtual bool store(FILE* f) const {
               ^
selforg/controller/abstractmulticontroller.h:127:22: note: Function in derived class
        virtual bool store(FILE* f) const;
                     ^
selforg/controller/abstractmulticontroller.h:131:22: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual bool restore(FILE* f);
                     ^
selforg/controller/abstractcontrolleradapter.h:147:16: note: Virtual function in base class
  virtual bool restore(FILE* f) {
               ^
selforg/controller/abstractmulticontroller.h:131:22: note: Function in derived class
        virtual bool restore(FILE* f);
                     ^
selforg/controller/abstractmulticontroller.h:127:22: style: The function 'store' overrides a function in a base class but is identical to the overridden function [uselessOverride]
        virtual bool store(FILE* f) const;
                     ^
selforg/controller/abstractcontrolleradapter.h:142:16: note: Virtual function in base class
  virtual bool store(FILE* f) const {
               ^
selforg/controller/abstractmulticontroller.h:127:22: note: Function in derived class
        virtual bool store(FILE* f) const;
                     ^
selforg/controller/abstractmulticontroller.h:131:22: style: The function 'restore' overrides a function in a base class but is identical to the overridden function [uselessOverride]
        virtual bool restore(FILE* f);
                     ^
selforg/controller/abstractcontrolleradapter.h:147:16: note: Virtual function in base class
  virtual bool restore(FILE* f) {
               ^
selforg/controller/abstractmulticontroller.h:131:22: note: Function in derived class
        virtual bool restore(FILE* f);
                     ^
selforg/controller/abstractmulticontroller.cpp:48:104: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (std::list<AbstractController*>::iterator i = controllerList.begin(); i != controllerList.end(); i++) {
                                                                                                       ^
4/142 files checked 1% done
Checking selforg/controller/classicreinforce.cpp ...
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::number_sensors' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::number_motors' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::x_buffer' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::y_buffer' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::x_context_buffer' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::oldaction' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::state' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::reward' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::oldreward' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
selforg/controller/classicreinforce.cpp:28:19: warning: Member variable 'ClassicReinforce::t' is not initialized in the constructor. [uninitMemberVar]
ClassicReinforce::ClassicReinforce( const ClassicReinforceConf& _conf)
                  ^
5/142 files checked 2% done
Checking selforg/controller/controllernet.cpp ...
selforg/controller/controllernet.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/layer.h:39:3: style: Class 'Layer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Layer(int size, double factor_bias=0.1,
  ^
selforg/controller/controllernet.h:42:3: style: Class 'ControllerNet' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  ControllerNet(const std::vector<Layer>& layers, bool useBypass=false);
  ^
selforg/matrix/matrix.h:83:6: style: The destructor '~Matrix' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~Matrix() { if(data) free(data); };
     ^
selforg/utils/storeable.h:35:12: note: Virtual destructor in base class
  virtual ~Storeable(){}
           ^
selforg/matrix/matrix.h:83:6: note: Destructor in derived class
    ~Matrix() { if(data) free(data); };
     ^
selforg/matrix/matrix.h:158:10: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool store(FILE* f) const;
         ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/matrix/matrix.h:158:10: note: Function in derived class
    bool store(FILE* f) const;
         ^
selforg/matrix/matrix.h:163:10: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool restore(FILE* f);
         ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/matrix/matrix.h:163:10: note: Function in derived class
    bool restore(FILE* f);
         ^
selforg/controller/abstractmodel.h:40:12: style: The destructor '~AbstractModel' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~AbstractModel(){};
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/abstractmodel.h:40:12: note: Destructor in derived class
  virtual ~AbstractModel(){};
           ^
selforg/controller/invertablemodel.h:39:12: style: The destructor '~InvertableModel' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~InvertableModel(){};
           ^
selforg/controller/abstractmodel.h:40:12: note: Virtual destructor in base class
  virtual ~AbstractModel(){};
           ^
selforg/controller/invertablemodel.h:39:12: note: Destructor in derived class
  virtual ~InvertableModel(){};
           ^
selforg/controller/feedforwardnn.h:47:12: style: The destructor '~FeedForwardNN' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~FeedForwardNN(){};
           ^
selforg/controller/invertablemodel.h:39:12: note: Virtual destructor in base class
  virtual ~InvertableModel(){};
           ^
selforg/controller/feedforwardnn.h:47:12: note: Destructor in derived class
  virtual ~FeedForwardNN(){};
           ^
selforg/controller/feedforwardnn.h:50:16: style: The function 'damp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void damp(double damping) =0 ;
               ^
selforg/controller/abstractmodel.h:68:16: note: Virtual function in base class
  virtual void damp(double damping)  = 0;
               ^
selforg/controller/feedforwardnn.h:50:16: note: Function in derived class
  virtual void damp(double damping) =0 ;
               ^
selforg/controller/layer.h:58:8: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool store(FILE* f) const;
       ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/layer.h:58:8: note: Function in derived class
  bool store(FILE* f) const;
       ^
selforg/controller/layer.h:60:8: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool restore(FILE* f);
       ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/layer.h:60:8: note: Function in derived class
  bool restore(FILE* f);
       ^
selforg/controller/controllernet.h:43:12: style: The destructor '~ControllerNet' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~ControllerNet(){ }
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/controllernet.h:43:12: note: Destructor in derived class
  virtual ~ControllerNet(){ }
           ^
selforg/controller/controllernet.cpp:476:12: warning: %i in format string (no. 1) requires 'int *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
        if(fscanf(f,"%i\n", &layernum) != 1) return false;
           ^
selforg/controller/controllernet.cpp:492:12: warning: %i in format string (no. 1) requires 'int *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
        if(fscanf(f,"%i\n#", &weightsnum) != 1) return false;
           ^
selforg/controller/regularisation.h:137:21: style: C-style pointer casting [cstyleCast]
    double size = *((double*)d);
                    ^
selforg/controller/controllernet.cpp:112:24: style: Unsigned expression 'injectInLayer' can't be negative so it is unnecessary to test it. [unsignedPositive]
  assert(injectInLayer >= 0 && injectInLayer < layernum);
                       ^
selforg/controller/controllernet.cpp:66:12: style: Local variable 'w' shadows outer variable [shadowVariable]
    Matrix w(layers[i].size, layers[i-1].size);
           ^
selforg/controller/controllernet.cpp:58:10: note: Shadowed declaration
  Matrix w(layers[0].size, inputDim);
         ^
selforg/controller/controllernet.cpp:66:12: note: Shadow variable
    Matrix w(layers[i].size, layers[i-1].size);
           ^
6/142 files checked 3% done
Checking selforg/controller/crossmotorcoupling.cpp ...
selforg/controller/crossmotorcoupling.h:60:12: style: C-style pointer casting [cstyleCast]
    assert((void*)t2==(void*)teachable);
           ^
7/142 files checked 3% done
Checking selforg/controller/dep.cpp ...
selforg/controller/dep.cpp:83:16: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
               ^
selforg/controller/dep.h:76:3: style: Class 'DEP' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DEP(const DEPConf& conf = getDefaultConf());
  ^
selforg/controller/dep.cpp:44:36: style: C-style pointer casting [cstyleCast]
  addParameterDef("learningrule",  (int*)(&this->conf.learningRule),
                                   ^
selforg/controller/dep.cpp:255:21: style: Local variable 'L' shadows outer variable [shadowVariable]
      const Matrix& L=A*C;
                    ^
selforg/controller/dep.h:142:18: note: Shadowed declaration
  matrix::Matrix L; // Jacobi Matrix
                 ^
selforg/controller/dep.cpp:255:21: note: Shadow variable
      const Matrix& L=A*C;
                    ^
selforg/controller/dep.cpp:83:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
8/142 files checked 4% done
Checking selforg/controller/derbigcontroller.cpp ...
selforg/controller/derbigcontroller.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/invertmotornstep.h:212:12: warning: The class 'InvertMotorNStep' defines member variable with name 'noiseY' also defined in its parent class 'InvertMotorController'. [duplInheritedMember]
  paramval noiseY; ///< noise strength for y
           ^
selforg/controller/invertmotorcontroller.h:63:12: note: Parent variable 'InvertMotorController::noiseY'
  paramval noiseY;     ///< size of the additional noise for motor values
           ^
selforg/controller/invertmotornstep.h:212:12: note: Derived variable 'InvertMotorNStep::noiseY'
  paramval noiseY; ///< noise strength for y
           ^
selforg/controller/derbigcontroller.h:57:3: style: Class 'DerBigController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DerBigController(const DerBigControllerConf& conf = getDefaultConf());
  ^
selforg/controller/invertmotornstep.h:58:3: style: Class 'InvertMotorNStep' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  InvertMotorNStep(const InvertMotorNStepConf& conf = getDefaultConf());
  ^
selforg/controller/derbigcontroller.h:58:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/derbigcontroller.h:58:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/derbigcontroller.h:60:12: style: The destructor '~DerBigController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~DerBigController();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/derbigcontroller.h:60:12: note: Destructor in derived class
  virtual ~DerBigController();
           ^
selforg/controller/derbigcontroller.h:63:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/derbigcontroller.h:63:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/derbigcontroller.h:65:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/derbigcontroller.h:65:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/derbigcontroller.h:69:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/derbigcontroller.h:69:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/derbigcontroller.h:72:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derbigcontroller.h:72:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derbigcontroller.h:78:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/derbigcontroller.h:78:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/derbigcontroller.h:80:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/derbigcontroller.h:80:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/invertmotornstep.h:60:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/invertmotornstep.h:60:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/invertmotornstep.h:62:12: style: The destructor '~InvertMotorNStep' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~InvertMotorNStep();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/invertmotornstep.h:62:12: note: Destructor in derived class
  virtual ~InvertMotorNStep();
           ^
selforg/controller/invertmotornstep.h:65:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/invertmotornstep.h:65:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/invertmotornstep.h:67:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/invertmotornstep.h:67:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/invertmotornstep.h:71:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/invertmotornstep.h:71:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/invertmotornstep.h:74:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertmotornstep.h:74:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertmotornstep.h:79:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/invertmotornstep.h:79:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/invertmotornstep.h:81:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/invertmotornstep.h:81:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/invertmotornstep.h:84:29: style: The function 'getStructuralLayers' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/utils/inspectable.h:137:22: note: Virtual function in base class
  virtual ilayerlist getStructuralLayers() const;
                     ^
selforg/controller/invertmotornstep.h:84:29: note: Function in derived class
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/controller/invertmotornstep.h:85:34: style: The function 'getStructuralConnections' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/utils/inspectable.h:144:27: note: Virtual function in base class
  virtual iconnectionlist getStructuralConnections() const;
                          ^
selforg/controller/invertmotornstep.h:85:34: note: Function in derived class
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/controller/invertmotornstep.h:111:16: style: The function 'setMotorTeaching' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void setMotorTeaching(const matrix::Matrix& teaching);
               ^
selforg/controller/teachable.h:43:16: note: Virtual function in base class
  virtual void setMotorTeaching(const matrix::Matrix& teaching) = 0;
               ^
selforg/controller/invertmotornstep.h:111:16: note: Function in derived class
  virtual void setMotorTeaching(const matrix::Matrix& teaching);
               ^
selforg/controller/invertmotornstep.h:118:16: style: The function 'setSensorTeaching' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void setSensorTeaching(const matrix::Matrix& teaching);
               ^
selforg/controller/teachable.h:50:16: note: Virtual function in base class
  virtual void setSensorTeaching(const matrix::Matrix& teaching) = 0;
               ^
selforg/controller/invertmotornstep.h:118:16: note: Function in derived class
  virtual void setSensorTeaching(const matrix::Matrix& teaching);
               ^
selforg/controller/invertmotornstep.h:120:26: style: The function 'getLastMotorValues' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual matrix::Matrix getLastMotorValues();
                         ^
selforg/controller/teachable.h:53:26: note: Virtual function in base class
  virtual matrix::Matrix getLastMotorValues() = 0;
                         ^
selforg/controller/invertmotornstep.h:120:26: note: Function in derived class
  virtual matrix::Matrix getLastMotorValues();
                         ^
selforg/controller/invertmotornstep.h:122:26: style: The function 'getLastSensorValues' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual matrix::Matrix getLastSensorValues();
                         ^
selforg/controller/teachable.h:56:26: note: Virtual function in base class
  virtual matrix::Matrix getLastSensorValues() = 0;
                         ^
selforg/controller/invertmotornstep.h:122:26: note: Function in derived class
  virtual matrix::Matrix getLastSensorValues();
                         ^
selforg/controller/invertmotornstep.h:154:18: performance: Function 'getSensorWeights()' should return member 'sensorweights' by const reference. [returnByReference]
  matrix::Matrix getSensorWeights() const {return sensorweights; }
                 ^
selforg/controller/derbigcontroller.cpp:250:19: style: Local variable 'y' shadows outer variable [shadowVariable]
    const Matrix& y          = y_buffer[(t-s-delay)%buffersize];
                  ^
selforg/controller/derbigcontroller.cpp:211:10: note: Shadowed declaration
  Matrix y = calculateControllerValues(x_smooth - x_smooth_long);//??????????????????????????????????????????????????????????);
         ^
selforg/controller/derbigcontroller.cpp:250:19: note: Shadow variable
    const Matrix& y          = y_buffer[(t-s-delay)%buffersize];
                  ^
selforg/controller/derbigcontroller.cpp:339:21: style: Local variable 'y' shadows outer variable [shadowVariable]
      const Matrix& y = y_buffer[(t)% buffersize]; // eventuell t-1
                    ^
selforg/controller/derbigcontroller.cpp:250:19: note: Shadowed declaration
    const Matrix& y          = y_buffer[(t-s-delay)%buffersize];
                  ^
selforg/controller/derbigcontroller.cpp:339:21: note: Shadow variable
      const Matrix& y = y_buffer[(t)% buffersize]; // eventuell t-1
                    ^
9/142 files checked 6% done
Checking selforg/controller/dercontroller.cpp ...
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::number_sensors' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::number_motors' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::xsi_norm' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::xsi_norm_avg' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::pain' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::x_buffer' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::y_buffer' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.cpp:32:16: warning: Member variable 'DerController::eta_buffer' is not initialized in the constructor. [uninitMemberVar]
DerController::DerController( const DerControllerConf& conf)
               ^
selforg/controller/dercontroller.h:56:3: style: Class 'DerController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DerController(const DerControllerConf& conf = getDefaultConf());
  ^
selforg/controller/dercontroller.h:57:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/dercontroller.h:57:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/dercontroller.h:59:12: style: The destructor '~DerController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~DerController();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/dercontroller.h:59:12: note: Destructor in derived class
  virtual ~DerController();
           ^
selforg/controller/dercontroller.h:62:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/dercontroller.h:62:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/dercontroller.h:64:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/dercontroller.h:64:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/dercontroller.h:68:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/dercontroller.h:68:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/dercontroller.h:71:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/dercontroller.h:71:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/dercontroller.h:76:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/dercontroller.h:76:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/dercontroller.h:77:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/dercontroller.h:77:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/dercontroller.h:82:29: style: The function 'getStructuralLayers' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/utils/inspectable.h:137:22: note: Virtual function in base class
  virtual ilayerlist getStructuralLayers() const;
                     ^
selforg/controller/dercontroller.h:82:29: note: Function in derived class
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/controller/dercontroller.h:83:34: style: The function 'getStructuralConnections' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/utils/inspectable.h:144:27: note: Virtual function in base class
  virtual iconnectionlist getStructuralConnections() const;
                          ^
selforg/controller/dercontroller.h:83:34: note: Function in derived class
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/controller/dercontroller.h:181:18: style: The function 'calcErrorFactor' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double calcErrorFactor(const matrix::Matrix& e, bool loga, bool root);
                 ^
selforg/controller/homeokinbase.h:100:18: note: Virtual function in base class
  virtual double calcErrorFactor(const matrix::Matrix& e, bool loga, bool root) {
                 ^
selforg/controller/dercontroller.h:181:18: note: Function in derived class
  virtual double calcErrorFactor(const matrix::Matrix& e, bool loga, bool root);
                 ^
selforg/controller/dercontroller.cpp:341:19: style: Local variable 'AAT' shadows outer variable [shadowVariable]
     const Matrix AAT = (A.multTM()+ SmallID)^-1;
                  ^
selforg/controller/dercontroller.h:122:18: note: Shadowed declaration
  matrix::Matrix AAT; // (A^T)*A
                 ^
selforg/controller/dercontroller.cpp:341:19: note: Shadow variable
     const Matrix AAT = (A.multTM()+ SmallID)^-1;
                  ^
10/142 files checked 8% done
Checking selforg/controller/derinf.cpp ...
selforg/controller/derinf.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::number_sensors' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::number_motors' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::xsi_norm' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::xsi_norm_avg' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::pain' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::TLE' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::grang1' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::grang2' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::causal' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::causalfactor' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::EE' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::EE_mean' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::EE_sqr' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::xsistrength' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::x_buffer' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::y_buffer' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::ysat_buffer' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::chi_buffer' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::rho_buffer' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::eta_buffer' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::xsi_buffer' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::t_rand' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.cpp:29:9: warning: Member variable 'DerInf::t_delay' is not initialized in the constructor. [uninitMemberVar]
DerInf::DerInf( const DerInfConf& conf)
        ^
selforg/controller/derinf.h:52:3: style: Class 'DerInf' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DerInf(const DerInfConf& conf = getDefaultConf());
  ^
selforg/controller/multilayerffnn.h:46:12: style: The destructor '~MultiLayerFFNN' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~MultiLayerFFNN(){ }
           ^
selforg/controller/feedforwardnn.h:47:12: note: Virtual destructor in base class
  virtual ~FeedForwardNN(){};
           ^
selforg/controller/multilayerffnn.h:46:12: note: Destructor in derived class
  virtual ~MultiLayerFFNN(){ }
           ^
selforg/controller/multilayerffnn.h:54:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/abstractmodel.h:50:16: note: Virtual function in base class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/multilayerffnn.h:54:16: note: Function in derived class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/multilayerffnn.h:58:32: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/abstractmodel.h:57:32: note: Virtual function in base class
  virtual const matrix::Matrix process (const matrix::Matrix& input)  = 0;
                               ^
selforg/controller/multilayerffnn.h:58:32: note: Function in derived class
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/multilayerffnn.h:62:32: style: The function 'learn' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/abstractmodel.h:63:32: note: Virtual function in base class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/multilayerffnn.h:62:32: note: Function in derived class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/multilayerffnn.h:74:32: style: The function 'response' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix response(const matrix::Matrix& input) const;
                               ^
selforg/controller/invertablemodel.h:47:32: note: Virtual function in base class
  virtual const matrix::Matrix response(const matrix::Matrix& input) const = 0;
                               ^
selforg/controller/multilayerffnn.h:74:32: note: Function in derived class
  virtual const matrix::Matrix response(const matrix::Matrix& input) const;
                               ^
selforg/controller/multilayerffnn.h:83:32: style: The function 'inversion' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix inversion(const matrix::Matrix& input, const matrix::Matrix& xsi) const;
                               ^
selforg/controller/invertablemodel.h:55:32: note: Virtual function in base class
  virtual const matrix::Matrix inversion(const matrix::Matrix& input, const matrix::Matrix& xsi) const = 0;
                               ^
selforg/controller/multilayerffnn.h:83:32: note: Function in derived class
  virtual const matrix::Matrix inversion(const matrix::Matrix& input, const matrix::Matrix& xsi) const;
                               ^
selforg/controller/multilayerffnn.h:87:24: style: The function 'getInputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getInputDim() const {
                       ^
selforg/controller/abstractmodel.h:71:24: note: Virtual function in base class
  virtual unsigned int getInputDim() const  = 0;
                       ^
selforg/controller/multilayerffnn.h:87:24: note: Function in derived class
  virtual unsigned int getInputDim() const {
                       ^
selforg/controller/multilayerffnn.h:91:24: style: The function 'getOutputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getOutputDim() const {
                       ^
selforg/controller/abstractmodel.h:73:24: note: Virtual function in base class
  virtual unsigned int getOutputDim() const  = 0;
                       ^
selforg/controller/multilayerffnn.h:91:24: note: Function in derived class
  virtual unsigned int getOutputDim() const {
                       ^
selforg/controller/multilayerffnn.h:102:16: style: The function 'damp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void damp(double damping);
               ^
selforg/controller/feedforwardnn.h:50:16: note: Virtual function in base class
  virtual void damp(double damping) =0 ;
               ^
selforg/controller/multilayerffnn.h:102:16: note: Function in derived class
  virtual void damp(double damping);
               ^
selforg/controller/multilayerffnn.h:147:8: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool store(FILE* f) const;
       ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/multilayerffnn.h:147:8: note: Function in derived class
  bool store(FILE* f) const;
       ^
selforg/controller/multilayerffnn.h:149:8: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool restore(FILE* f);
       ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/multilayerffnn.h:149:8: note: Function in derived class
  bool restore(FILE* f);
       ^
selforg/controller/derinf.h:53:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randg);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/derinf.h:53:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randg);
               ^
selforg/controller/derinf.h:55:12: style: The destructor '~DerInf' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~DerInf();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/derinf.h:55:12: note: Destructor in derived class
  virtual ~DerInf();
           ^
selforg/controller/derinf.h:58:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/derinf.h:58:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/derinf.h:60:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/derinf.h:60:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/derinf.h:64:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/derinf.h:64:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/derinf.h:67:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derinf.h:67:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derinf.h:72:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/derinf.h:72:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/derinf.h:74:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/derinf.h:74:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/derinf.cpp:77:11: style: Variable 'randg' is assigned a value that is never used. [unreadVariable]
    randg = new RandGen();
          ^
11/142 files checked 9% done
Checking selforg/controller/derlininvert.cpp ...
selforg/controller/derlininvert.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/derlininvert.h:58:3: style: Class 'DerLinInvert' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DerLinInvert(const DerLinInvertConf& conf = getDefaultConf());
  ^
selforg/controller/derlininvert.h:59:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randg);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/derlininvert.h:59:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randg);
               ^
selforg/controller/derlininvert.h:61:12: style: The destructor '~DerLinInvert' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~DerLinInvert();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/derlininvert.h:61:12: note: Destructor in derived class
  virtual ~DerLinInvert();
           ^
selforg/controller/derlininvert.h:64:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/derlininvert.h:64:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/derlininvert.h:66:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/derlininvert.h:66:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/derlininvert.h:70:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/derlininvert.h:70:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/derlininvert.h:73:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derlininvert.h:73:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derlininvert.h:79:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/derlininvert.h:79:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/derlininvert.h:81:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/derlininvert.h:81:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/derlininvert.cpp:361:20: style: Local variable 'mue1' shadows outer variable [shadowVariable]
   const Matrix    mue1 = xsi;
                   ^
selforg/controller/derlininvert.h:185:18: note: Shadowed declaration
  matrix::Matrix mue1;
                 ^
selforg/controller/derlininvert.cpp:361:20: note: Shadow variable
   const Matrix    mue1 = xsi;
                   ^
selforg/controller/derlininvert.cpp:75:11: style: Variable 'randg' is assigned a value that is never used. [unreadVariable]
    randg = new RandGen();
          ^
selforg/controller/derlininvert.cpp:482:13: style: Variable 'C_update' is assigned a value that is never used. [unreadVariable]
   C_update += delta * (x^T)*teacher;//*causalfactor ;// *epsC;
            ^
selforg/controller/derlininvert.cpp:484:13: style: Variable 'H_update' is assigned a value that is never used. [unreadVariable]
   H_update += (C^T) * delta  * teacher;//*causalfactor;// *epsC; TEST H ??????????
            ^
12/142 files checked 11% done
Checking selforg/controller/derlinunivers.cpp ...
selforg/controller/derlinunivers.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/derlinunivers.cpp:33:16: warning: Member variable 'DerLinUnivers::x_buffer' is not initialized in the constructor. [uninitMemberVar]
DerLinUnivers::DerLinUnivers(const DerLinUniversConf& conf)
               ^
selforg/controller/derlinunivers.cpp:33:16: warning: Member variable 'DerLinUnivers::y_buffer' is not initialized in the constructor. [uninitMemberVar]
DerLinUnivers::DerLinUnivers(const DerLinUniversConf& conf)
               ^
selforg/controller/derlinunivers.cpp:33:16: warning: Member variable 'DerLinUnivers::v_buffer' is not initialized in the constructor. [uninitMemberVar]
DerLinUnivers::DerLinUnivers(const DerLinUniversConf& conf)
               ^
selforg/controller/derlinunivers.h:73:3: style: Class 'DerLinUnivers' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DerLinUnivers(const DerLinUniversConf& conf = getDefaultConf());
  ^
selforg/controller/elman.h:72:12: style: The destructor '~Elman' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~Elman(){ }
           ^
selforg/controller/multilayerffnn.h:46:12: note: Virtual destructor in base class
  virtual ~MultiLayerFFNN(){ }
           ^
selforg/controller/elman.h:72:12: note: Destructor in derived class
  virtual ~Elman(){ }
           ^
selforg/controller/elman.h:75:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/multilayerffnn.h:54:16: note: Virtual function in base class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/elman.h:75:16: note: Function in derived class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/elman.h:81:32: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/multilayerffnn.h:58:32: note: Virtual function in base class
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/elman.h:81:32: note: Function in derived class
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/elman.h:84:32: style: The function 'learn' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/multilayerffnn.h:62:32: note: Virtual function in base class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/elman.h:84:32: note: Function in derived class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/elman.h:112:8: style: The function 'damp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  void damp(double damping);
       ^
selforg/controller/multilayerffnn.h:102:16: note: Virtual function in base class
  virtual void damp(double damping);
               ^
selforg/controller/elman.h:112:8: note: Function in derived class
  void damp(double damping);
       ^
selforg/controller/elman.h:116:8: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool store(FILE* f) const;
       ^
selforg/controller/multilayerffnn.h:147:8: note: Virtual function in base class
  bool store(FILE* f) const;
       ^
selforg/controller/elman.h:116:8: note: Function in derived class
  bool store(FILE* f) const;
       ^
selforg/controller/elman.h:118:8: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool restore(FILE* f);
       ^
selforg/controller/multilayerffnn.h:149:8: note: Virtual function in base class
  bool restore(FILE* f);
       ^
selforg/controller/elman.h:118:8: note: Function in derived class
  bool restore(FILE* f);
       ^
selforg/controller/elman.h:129:25: style: The function 'getInternalParamNames' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual iparamkeylist getInternalParamNames() const;
                        ^
selforg/controller/multilayerffnn.h:156:25: note: Virtual function in base class
  virtual iparamkeylist getInternalParamNames() const;
                        ^
selforg/controller/elman.h:129:25: note: Function in derived class
  virtual iparamkeylist getInternalParamNames() const;
                        ^
selforg/controller/elman.h:130:25: style: The function 'getInternalParams' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual iparamvallist getInternalParams() const;
                        ^
selforg/controller/multilayerffnn.h:157:25: note: Virtual function in base class
  virtual iparamvallist getInternalParams() const;
                        ^
selforg/controller/elman.h:130:25: note: Function in derived class
  virtual iparamvallist getInternalParams() const;
                        ^
selforg/controller/elman.h:131:22: style: The function 'getStructuralLayers' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ilayerlist getStructuralLayers() const;
                     ^
selforg/controller/multilayerffnn.h:158:22: note: Virtual function in base class
  virtual ilayerlist getStructuralLayers() const;
                     ^
selforg/controller/elman.h:131:22: note: Function in derived class
  virtual ilayerlist getStructuralLayers() const;
                     ^
selforg/controller/elman.h:132:27: style: The function 'getStructuralConnections' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual iconnectionlist getStructuralConnections() const;
                          ^
selforg/controller/multilayerffnn.h:159:27: note: Virtual function in base class
  virtual iconnectionlist getStructuralConnections() const;
                          ^
selforg/controller/elman.h:132:27: note: Function in derived class
  virtual iconnectionlist getStructuralConnections() const;
                          ^
selforg/controller/derlinunivers.h:74:12: style: The destructor '~DerLinUnivers' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~DerLinUnivers();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/derlinunivers.h:74:12: note: Destructor in derived class
  virtual ~DerLinUnivers();
           ^
selforg/controller/derlinunivers.h:100:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/derlinunivers.h:100:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/derlinunivers.h:102:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const {return number_sensors;}
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/derlinunivers.h:102:15: note: Function in derived class
  virtual int getSensorNumber() const {return number_sensors;}
              ^
selforg/controller/derlinunivers.h:104:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const {return number_motors;}
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/derlinunivers.h:104:15: note: Function in derived class
  virtual int getMotorNumber() const {return number_motors;}
              ^
selforg/controller/derlinunivers.h:106:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/derlinunivers.h:106:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/derlinunivers.h:109:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derlinunivers.h:109:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derlinunivers.h:146:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/derlinunivers.h:146:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/derlinunivers.h:147:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/derlinunivers.h:147:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/derlinunivers.cpp:62:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
13/142 files checked 12% done
Checking selforg/controller/derpseudosensor.cpp ...
selforg/controller/derpseudosensor.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/derpseudosensor.h:61:3: style: Class 'DerPseudoSensor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DerPseudoSensor(const DerPseudoSensorConf& conf = getDefaultConf());
  ^
selforg/controller/derpseudosensor.h:62:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/derpseudosensor.h:62:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/derpseudosensor.h:64:12: style: The destructor '~DerPseudoSensor' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~DerPseudoSensor();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/derpseudosensor.h:64:12: note: Destructor in derived class
  virtual ~DerPseudoSensor();
           ^
selforg/controller/derpseudosensor.h:67:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/derpseudosensor.h:67:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/derpseudosensor.h:69:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/derpseudosensor.h:69:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/derpseudosensor.h:73:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/derpseudosensor.h:73:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/derpseudosensor.h:76:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derpseudosensor.h:76:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/derpseudosensor.h:82:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/derpseudosensor.h:82:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/derpseudosensor.h:84:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/derpseudosensor.h:84:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/derpseudosensor.cpp:389:19: style: Local variable 'y' shadows outer variable [shadowVariable]
    const Matrix& y = y_buffer[(t)% buffersize]; // eventuell t-1
                  ^
selforg/controller/derpseudosensor.cpp:218:17: note: Shadowed declaration
  const Matrix& y = calculateControllerValues( x_smooth);// y_buffer[(t-delay)%buffersize];
                ^
selforg/controller/derpseudosensor.cpp:389:19: note: Shadow variable
    const Matrix& y = y_buffer[(t)% buffersize]; // eventuell t-1
                  ^
selforg/controller/derpseudosensor.cpp:392:19: style: Local variable 'delta' shadows outer variable [shadowVariable]
    const Matrix& delta = ( kappa ).multrowwise(g_p);
                  ^
selforg/controller/derpseudosensor.cpp:351:17: note: Shadowed declaration
   const Matrix delta = ( y_sat*.99 - y ).multrowwise(g_prime);
                ^
selforg/controller/derpseudosensor.cpp:392:19: note: Shadow variable
    const Matrix& delta = ( kappa ).multrowwise(g_p);
                  ^
selforg/controller/derpseudosensor.cpp:384:22: style: Variable 'C_updateTeaching' is assigned a value that is never used. [unreadVariable]
    C_updateTeaching += ( g_eta*(x^T) ) * conf.modelCompliant * epsC;
                     ^
selforg/controller/derpseudosensor.cpp:385:22: style: Variable 'H_updateTeaching' is assigned a value that is never used. [unreadVariable]
    H_updateTeaching += g_eta * conf.modelCompliant * epsC;
                     ^
selforg/controller/derpseudosensor.cpp:393:22: style: Variable 'C_updateTeaching' is assigned a value that is never used. [unreadVariable]
    C_updateTeaching += ( delta*(x^T) ) * teacher;// * epsC;
                     ^
selforg/controller/derpseudosensor.cpp:394:22: style: Variable 'H_updateTeaching' is assigned a value that is never used. [unreadVariable]
    H_updateTeaching += delta * teacher;// * epsC;
                     ^
14/142 files checked 14% done
Checking selforg/controller/discretecontrolleradapter.cpp ...
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::mapToMotorInterval' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::minMotorRange' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::maxMotorRange' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::minSensorRange' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::maxSensorRange' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::minMotorValue' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::maxMotorValue' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::minSensorValue' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::maxSensorValue' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.cpp:49:28: warning: Member variable 'DiscreteControllerAdapter::discreteSensors' is not initialized in the constructor. [uninitMemberVar]
DiscreteControllerAdapter::DiscreteControllerAdapter(AbstractController* controller, const std::string& name, const std::string& revision)
                           ^
selforg/controller/discretecontrolleradapter.h:58:14: style: The destructor '~DiscreteControllerAdapter' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~DiscreteControllerAdapter();
             ^
selforg/controller/abstractcontrolleradapter.h:63:12: note: Virtual destructor in base class
  virtual ~AbstractControllerAdapter() {}
           ^
selforg/controller/discretecontrolleradapter.h:58:14: note: Destructor in derived class
    virtual ~DiscreteControllerAdapter();
             ^
selforg/controller/discretecontrolleradapter.h:139:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontrolleradapter.h:99:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/discretecontrolleradapter.h:139:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/discretecontrolleradapter.h:144:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor*, int number_sensors,
               ^
selforg/controller/abstractcontrolleradapter.h:107:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/discretecontrolleradapter.h:144:16: note: Function in derived class
  virtual void stepNoLearning(const sensor*, int number_sensors,
               ^
selforg/controller/discretecontrolleradapter.h:150:22: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
                     ^
selforg/controller/abstractcontrolleradapter.h:80:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0){
               ^
selforg/controller/discretecontrolleradapter.h:150:22: note: Function in derived class
        virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
                     ^
selforg/controller/discretecontrolleradapter.cpp:129:27: style: C-style pointer casting [cstyleCast]
  this->discreteSensors = (sensor*) malloc(sizeof(sensor) * sensornumber);
                          ^
15/142 files checked 15% done
Checking selforg/controller/elman.cpp ...
selforg/controller/elman.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/elman.cpp:321:6: style: The if condition is the same as the previous if condition [duplicateCondition]
  if(useElman)
     ^
selforg/controller/elman.cpp:319:6: note: First condition
  if(useElman)
     ^
selforg/controller/elman.cpp:321:6: note: Second condition
  if(useElman)
     ^
selforg/controller/elman.cpp:183:15: style: Local variable 'k' shadows outer variable [shadowVariable]
      for(int k=blockfrom; k<blockto; k++) delta.val(k,0)=0;
              ^
selforg/controller/elman.cpp:170:7: note: Shadowed declaration
  int k = 0;
      ^
selforg/controller/elman.cpp:183:15: note: Shadow variable
      for(int k=blockfrom; k<blockto; k++) delta.val(k,0)=0;
              ^
16/142 files checked 16% done
Checking selforg/controller/esn.cpp ...
selforg/controller/esn.cpp:35:6: warning: Member variable 'ESN::nbInputs' is not initialized in the constructor. [uninitMemberVar]
ESN::ESN(const ESNConf& _conf)
     ^
selforg/controller/esn.cpp:35:6: warning: Member variable 'ESN::nbOutputs' is not initialized in the constructor. [uninitMemberVar]
ESN::ESN(const ESNConf& _conf)
     ^
selforg/controller/esn.h:59:3: style: Class 'ESN' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  ESN(const ESNConf& conf = getDefaultConf());
  ^
17/142 files checked 17% done
Checking selforg/controller/ffnncontroller.cpp ...
selforg/controller/ffnncontroller.cpp:6:17: warning: Member variable 'FFNNController::number_motors' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(const std::string& networkfilename, int history, bool input_only_x, unsigned int init_wait)
                ^
selforg/controller/ffnncontroller.cpp:6:17: warning: Member variable 'FFNNController::number_sensors' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(const std::string& networkfilename, int history, bool input_only_x, unsigned int init_wait)
                ^
selforg/controller/ffnncontroller.cpp:6:17: warning: Member variable 'FFNNController::x_buffer' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(const std::string& networkfilename, int history, bool input_only_x, unsigned int init_wait)
                ^
selforg/controller/ffnncontroller.cpp:6:17: warning: Member variable 'FFNNController::y_buffer' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(const std::string& networkfilename, int history, bool input_only_x, unsigned int init_wait)
                ^
selforg/controller/ffnncontroller.cpp:20:17: warning: Member variable 'FFNNController::number_motors' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(MultiLayerFFNN* net, int history, bool input_only_x,
                ^
selforg/controller/ffnncontroller.cpp:20:17: warning: Member variable 'FFNNController::number_sensors' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(MultiLayerFFNN* net, int history, bool input_only_x,
                ^
selforg/controller/ffnncontroller.cpp:20:17: warning: Member variable 'FFNNController::x_buffer' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(MultiLayerFFNN* net, int history, bool input_only_x,
                ^
selforg/controller/ffnncontroller.cpp:20:17: warning: Member variable 'FFNNController::y_buffer' is not initialized in the constructor. [uninitMemberVar]
FFNNController::FFNNController(MultiLayerFFNN* net, int history, bool input_only_x,
                ^
selforg/controller/ffnncontroller.cpp:9:3: warning: Class 'FFNNController' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
  net = new MultiLayerFFNN( 0.01, std::vector<Layer>());
  ^
selforg/controller/ffnncontroller.cpp:9:3: warning: Class 'FFNNController' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
  net = new MultiLayerFFNN( 0.01, std::vector<Layer>());
  ^
selforg/controller/ffnncontroller.h:51:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/ffnncontroller.h:51:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/ffnncontroller.h:53:12: style: The destructor '~FFNNController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~FFNNController();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/ffnncontroller.h:53:12: note: Destructor in derived class
  virtual ~FFNNController();
           ^
selforg/controller/ffnncontroller.h:56:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/ffnncontroller.h:56:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/ffnncontroller.h:58:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/ffnncontroller.h:58:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/ffnncontroller.h:60:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/ffnncontroller.h:60:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/ffnncontroller.h:61:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/ffnncontroller.h:61:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/ffnncontroller.h:69:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/ffnncontroller.h:69:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/ffnncontroller.h:71:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/ffnncontroller.h:71:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
18/142 files checked 17% done
Checking selforg/controller/invertmotorbigmodel.cpp ...
selforg/controller/invertmotorbigmodel.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/invertmotorbigmodel.h:57:3: style: Class 'InvertMotorBigModel' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  InvertMotorBigModel(const InvertMotorBigModelConf& conf = getDefaultConf());
  ^
selforg/controller/invertmotorbigmodel.h:58:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/invertmotorbigmodel.h:58:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/invertmotorbigmodel.h:60:12: style: The destructor '~InvertMotorBigModel' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~InvertMotorBigModel();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/invertmotorbigmodel.h:60:12: note: Destructor in derived class
  virtual ~InvertMotorBigModel();
           ^
selforg/controller/invertmotorbigmodel.h:63:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/invertmotorbigmodel.h:63:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/invertmotorbigmodel.h:65:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/invertmotorbigmodel.h:65:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/invertmotorbigmodel.h:69:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/invertmotorbigmodel.h:69:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/invertmotorbigmodel.h:72:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertmotorbigmodel.h:72:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertmotorbigmodel.h:78:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/invertmotorbigmodel.h:78:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/invertmotorbigmodel.h:80:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/invertmotorbigmodel.h:80:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/invertmotorbigmodel.cpp:247:21: style: Local variable 'xsi' shadows outer variable [shadowVariable]
      const Matrix& xsi = y_teaching - y;
                    ^
selforg/controller/invertmotorbigmodel.h:129:18: note: Shadowed declaration
  matrix::Matrix xsi; ///< current output error
                 ^
selforg/controller/invertmotorbigmodel.cpp:247:21: note: Shadow variable
      const Matrix& xsi = y_teaching - y;
                    ^
19/142 files checked 19% done
Checking selforg/controller/invertmotornstep.cpp ...
selforg/controller/invertmotornstep.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/invertmotornstep.cpp:26:19: warning: Member variable 'InvertMotorNStep::number_sensors' is not initialized in the constructor. [uninitMemberVar]
InvertMotorNStep::InvertMotorNStep( const InvertMotorNStepConf& conf)
                  ^
selforg/controller/invertmotornstep.cpp:26:19: warning: Member variable 'InvertMotorNStep::number_motors' is not initialized in the constructor. [uninitMemberVar]
InvertMotorNStep::InvertMotorNStep( const InvertMotorNStepConf& conf)
                  ^
selforg/controller/invertmotornstep.cpp:26:19: warning: Member variable 'InvertMotorNStep::t_rand' is not initialized in the constructor. [uninitMemberVar]
InvertMotorNStep::InvertMotorNStep( const InvertMotorNStepConf& conf)
                  ^
selforg/controller/invertmotornstep.cpp:410:21: style: Local variable 'xsi' shadows outer variable [shadowVariable]
      const Matrix& xsi = y_tm2 - y_tm1;
                    ^
selforg/controller/invertmotornstep.h:176:18: note: Shadowed declaration
  matrix::Matrix xsi; ///< current output error
                 ^
selforg/controller/invertmotornstep.cpp:410:21: note: Shadow variable
      const Matrix& xsi = y_tm2 - y_tm1;
                    ^
selforg/controller/invertmotornstep.cpp:425:21: style: Local variable 'xsi' shadows outer variable [shadowVariable]
      const Matrix& xsi = y_teaching - y;
                    ^
selforg/controller/invertmotornstep.h:176:18: note: Shadowed declaration
  matrix::Matrix xsi; ///< current output error
                 ^
selforg/controller/invertmotornstep.cpp:425:21: note: Shadow variable
      const Matrix& xsi = y_teaching - y;
                    ^
selforg/controller/invertmotornstep.cpp:470:16: style: Local variable 'v' shadows outer variable [shadowVariable]
  const Matrix v   = ((R + SmallID)^-1) * zeta;
               ^
selforg/controller/invertmotornstep.h:177:18: note: Shadowed declaration
  matrix::Matrix v;   ///< current reconstructed error
                 ^
selforg/controller/invertmotornstep.cpp:470:16: note: Shadow variable
  const Matrix v   = ((R + SmallID)^-1) * zeta;
               ^
20/142 files checked 21% done
Checking selforg/controller/invertmotorspace.cpp ...
selforg/controller/invertmotorspace.cpp:25:19: warning: Member variable 'InvertMotorSpace::number_sensors' is not initialized in the constructor. [uninitMemberVar]
InvertMotorSpace::InvertMotorSpace( int buffersize, double cInit /* = 0.1 */, bool someInternalParams /* = true*/)
                  ^
selforg/controller/invertmotorspace.cpp:25:19: warning: Member variable 'InvertMotorSpace::number_motors' is not initialized in the constructor. [uninitMemberVar]
InvertMotorSpace::InvertMotorSpace( int buffersize, double cInit /* = 0.1 */, bool someInternalParams /* = true*/)
                  ^
selforg/controller/invertmotorspace.h:39:3: style: Class 'InvertMotorSpace' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  InvertMotorSpace(int buffersize, double cInit = 0.1 , bool someInternalParams = true);
  ^
selforg/controller/invertmotorspace.h:40:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/invertmotorspace.h:40:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/invertmotorspace.h:42:12: style: The destructor '~InvertMotorSpace' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~InvertMotorSpace();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/invertmotorspace.h:42:12: note: Destructor in derived class
  virtual ~InvertMotorSpace();
           ^
selforg/controller/invertmotorspace.h:45:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/invertmotorspace.h:45:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/invertmotorspace.h:47:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/invertmotorspace.h:47:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/invertmotorspace.h:51:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/invertmotorspace.h:51:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/invertmotorspace.h:54:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertmotorspace.h:54:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertmotorspace.h:59:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/invertmotorspace.h:59:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/invertmotorspace.h:61:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/invertmotorspace.h:61:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/invertmotorspace.h:64:29: style: The function 'getStructuralLayers' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/utils/inspectable.h:137:22: note: Virtual function in base class
  virtual ilayerlist getStructuralLayers() const;
                     ^
selforg/controller/invertmotorspace.h:64:29: note: Function in derived class
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/controller/invertmotorspace.h:65:34: style: The function 'getStructuralConnections' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/utils/inspectable.h:144:27: note: Virtual function in base class
  virtual iconnectionlist getStructuralConnections() const;
                          ^
selforg/controller/invertmotorspace.h:65:34: note: Function in derived class
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/controller/invertmotorspace.cpp:54:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
21/142 files checked 22% done
Checking selforg/controller/invertnchannelcontroller.cpp ...
selforg/controller/invertnchannelcontroller.cpp:26:27: warning: Member variable 'InvertNChannelController::number_channels' is not initialized in the constructor. [uninitMemberVar]
InvertNChannelController::InvertNChannelController(int _buffersize, bool _update_only_1/*=false*/)
                          ^
selforg/controller/invertnchannelcontroller.h:86:12: warning: The class 'InvertNChannelController' defines member variable with name 'name' also defined in its parent class 'Inspectable'. [duplInheritedMember]
  paramkey name;
           ^
selforg/utils/inspectable.h:254:13: note: Parent variable 'Inspectable::name'
  iparamkey name;
            ^
selforg/controller/invertnchannelcontroller.h:86:12: note: Derived variable 'InvertNChannelController::name'
  paramkey name;
           ^
selforg/controller/invertnchannelcontroller.h:41:3: style: Class 'InvertNChannelController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  InvertNChannelController(int _buffersize, bool _update_only_1=false);
  ^
selforg/controller/invertnchannelcontroller.h:42:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/invertnchannelcontroller.h:42:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/invertnchannelcontroller.h:44:12: style: The destructor '~InvertNChannelController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~InvertNChannelController();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/invertnchannelcontroller.h:44:12: note: Destructor in derived class
  virtual ~InvertNChannelController();
           ^
selforg/controller/invertnchannelcontroller.h:49:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_channels; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/invertnchannelcontroller.h:49:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_channels; }
              ^
selforg/controller/invertnchannelcontroller.h:51:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_channels; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/invertnchannelcontroller.h:51:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_channels; }
              ^
selforg/controller/invertnchannelcontroller.h:55:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/invertnchannelcontroller.h:55:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/invertnchannelcontroller.h:59:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertnchannelcontroller.h:59:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/invertnchannelcontroller.h:65:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/invertnchannelcontroller.h:65:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/invertnchannelcontroller.h:67:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/invertnchannelcontroller.h:67:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/invertnchannelcontroller.h:70:29: style: The function 'getStructuralLayers' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/utils/inspectable.h:137:22: note: Virtual function in base class
  virtual ilayerlist getStructuralLayers() const;
                     ^
selforg/controller/invertnchannelcontroller.h:70:29: note: Function in derived class
  virtual std::list<ILayer> getStructuralLayers() const;
                            ^
selforg/controller/invertnchannelcontroller.h:71:34: style: The function 'getStructuralConnections' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/utils/inspectable.h:144:27: note: Virtual function in base class
  virtual iconnectionlist getStructuralConnections() const;
                          ^
selforg/controller/invertnchannelcontroller.h:71:34: note: Function in derived class
  virtual std::list<IConnection> getStructuralConnections() const;
                                 ^
selforg/controller/invertnchannelcontroller.cpp:46:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
22/142 files checked 23% done
Checking selforg/controller/layer.cpp ...
selforg/controller/layer.cpp:85:12: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
        if(sscanf(buffer,"%i %lf %s", &size, &factor_bias, buffer) != 3) return false;
           ^
23/142 files checked 23% done
Checking selforg/controller/measureadapter.cpp ...
selforg/controller/measureadapter.h:29:0: information: Include file: "statistictools.h" not found. [missingInclude]
#include "statistictools.h"
^
selforg/controller/measureadapter.h:30:0: information: Include file: "complexmeasure.h" not found. [missingInclude]
#include "complexmeasure.h"
^
selforg/controller/measureadapter.cpp:27:17: warning: Member variable 'MeasureAdapter::initialized' is not initialized in the constructor. [uninitMemberVar]
MeasureAdapter::MeasureAdapter(AbstractController* controller, const std::string& name, const std::string& revision ) :
                ^
selforg/controller/measureadapter.cpp:27:17: warning: Member variable 'MeasureAdapter::motorValues' is not initialized in the constructor. [uninitMemberVar]
MeasureAdapter::MeasureAdapter(AbstractController* controller, const std::string& name, const std::string& revision ) :
                ^
selforg/controller/measureadapter.cpp:27:17: warning: Member variable 'MeasureAdapter::sensorValues' is not initialized in the constructor. [uninitMemberVar]
MeasureAdapter::MeasureAdapter(AbstractController* controller, const std::string& name, const std::string& revision ) :
                ^
selforg/controller/measureadapter.cpp:29:3: warning: Class 'MeasureAdapter' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
  st = new StatisticTools("MeasureAdapter's ST");
  ^
selforg/controller/measureadapter.cpp:29:3: warning: Class 'MeasureAdapter' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
  st = new StatisticTools("MeasureAdapter's ST");
  ^
selforg/controller/measureadapter.h:49:3: style: Class 'MeasureAdapter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  MeasureAdapter(AbstractController* controller, const std::string& name = "MeasureAdapter", const std::string& revision = "$ID$");
  ^
selforg/controller/measureadapter.h:51:12: style: The destructor '~MeasureAdapter' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~MeasureAdapter();
           ^
selforg/controller/abstractcontrolleradapter.h:63:12: note: Virtual destructor in base class
  virtual ~AbstractControllerAdapter() {}
           ^
selforg/controller/measureadapter.h:51:12: note: Destructor in derived class
  virtual ~MeasureAdapter();
           ^
selforg/controller/measureadapter.h:68:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontrolleradapter.h:80:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0){
               ^
selforg/controller/measureadapter.h:68:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/measureadapter.h:77:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontrolleradapter.h:99:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/measureadapter.h:77:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/measureadapter.h:83:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/abstractcontrolleradapter.h:107:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/measureadapter.h:83:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/measureadapter.cpp:78:23: style: C-style pointer casting [cstyleCast]
  this->motorValues = (motor*) malloc(sizeof(motor) * motornumber);
                      ^
selforg/controller/measureadapter.cpp:79:24: style: C-style pointer casting [cstyleCast]
  this->sensorValues = (sensor*) malloc(sizeof(sensor) * sensornumber);
                       ^
24/142 files checked 23% done
Checking selforg/controller/modelwithmemoryadapter.cpp ...
selforg/controller/modelwithmemoryadapter.h:40:12: style: The destructor '~ModelWithMemoryAdapter' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~ModelWithMemoryAdapter(){ }
           ^
selforg/controller/invertablemodel.h:39:12: note: Virtual destructor in base class
  virtual ~InvertableModel(){};
           ^
selforg/controller/modelwithmemoryadapter.h:40:12: note: Destructor in derived class
  virtual ~ModelWithMemoryAdapter(){ }
           ^
selforg/controller/modelwithmemoryadapter.h:42:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/abstractmodel.h:50:16: note: Virtual function in base class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/modelwithmemoryadapter.h:42:16: note: Function in derived class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/modelwithmemoryadapter.h:49:32: style: The function 'learn' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/abstractmodel.h:63:32: note: Virtual function in base class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/modelwithmemoryadapter.h:49:32: note: Function in derived class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/modelwithmemoryadapter.h:55:32: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix process (const matrix::Matrix& input){
                               ^
selforg/controller/abstractmodel.h:57:32: note: Virtual function in base class
  virtual const matrix::Matrix process (const matrix::Matrix& input)  = 0;
                               ^
selforg/controller/modelwithmemoryadapter.h:55:32: note: Function in derived class
  virtual const matrix::Matrix process (const matrix::Matrix& input){
                               ^
selforg/controller/modelwithmemoryadapter.h:59:32: style: The function 'response' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix response(const matrix::Matrix& input) const{
                               ^
selforg/controller/invertablemodel.h:47:32: note: Virtual function in base class
  virtual const matrix::Matrix response(const matrix::Matrix& input) const = 0;
                               ^
selforg/controller/modelwithmemoryadapter.h:59:32: note: Function in derived class
  virtual const matrix::Matrix response(const matrix::Matrix& input) const{
                               ^
selforg/controller/modelwithmemoryadapter.h:63:32: style: The function 'inversion' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix inversion(const matrix::Matrix& input,
                               ^
selforg/controller/invertablemodel.h:55:32: note: Virtual function in base class
  virtual const matrix::Matrix inversion(const matrix::Matrix& input, const matrix::Matrix& xsi) const = 0;
                               ^
selforg/controller/modelwithmemoryadapter.h:63:32: note: Function in derived class
  virtual const matrix::Matrix inversion(const matrix::Matrix& input,
                               ^
selforg/controller/modelwithmemoryadapter.h:67:24: style: The function 'getInputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getInputDim() const {
                       ^
selforg/controller/abstractmodel.h:71:24: note: Virtual function in base class
  virtual unsigned int getInputDim() const  = 0;
                       ^
selforg/controller/modelwithmemoryadapter.h:67:24: note: Function in derived class
  virtual unsigned int getInputDim() const {
                       ^
selforg/controller/modelwithmemoryadapter.h:70:24: style: The function 'getOutputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getOutputDim() const {
                       ^
selforg/controller/abstractmodel.h:73:24: note: Virtual function in base class
  virtual unsigned int getOutputDim() const  = 0;
                       ^
selforg/controller/modelwithmemoryadapter.h:70:24: note: Function in derived class
  virtual unsigned int getOutputDim() const {
                       ^
selforg/controller/modelwithmemoryadapter.h:73:16: style: The function 'damp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void damp(double damping) { model->damp(damping);}
               ^
selforg/controller/abstractmodel.h:68:16: note: Virtual function in base class
  virtual void damp(double damping)  = 0;
               ^
selforg/controller/modelwithmemoryadapter.h:73:16: note: Function in derived class
  virtual void damp(double damping) { model->damp(damping);}
               ^
selforg/controller/modelwithmemoryadapter.h:87:8: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool store(FILE* f) const { return model->store(f);}
       ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/modelwithmemoryadapter.h:87:8: note: Function in derived class
  bool store(FILE* f) const { return model->store(f);}
       ^
selforg/controller/modelwithmemoryadapter.h:89:8: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool restore(FILE* f){ return model->restore(f);}
       ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/modelwithmemoryadapter.h:89:8: note: Function in derived class
  bool restore(FILE* f){ return model->restore(f);}
       ^
selforg/controller/modelwithmemoryadapter.h:116:12: style: Class 'ModelWithMemoryAdapter' is unsafe, 'ModelWithMemoryAdapter::randGen' can leak by wrong usage. [unsafeClassCanLeak]
  RandGen* randGen;
           ^
25/142 files checked 24% done
Checking selforg/controller/motorbabbler.cpp ...
selforg/controller/motorbabbler.h:43:3: style: Class 'MotorBabbler' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  MotorBabbler(function func = Sine );
  ^
selforg/controller/motorbabbler.cpp:83:27: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour. See condition at line 83. [shiftTooManyBitsSigned]
    if(i>=32 || (mask & (1<<i))){
                          ^
selforg/controller/motorbabbler.cpp:83:9: note: Assuming that condition 'i>=32' is not redundant
    if(i>=32 || (mask & (1<<i))){
        ^
selforg/controller/motorbabbler.cpp:83:27: note: Shift
    if(i>=32 || (mask & (1<<i))){
                          ^
26/142 files checked 24% done
Checking selforg/controller/multilayerffnn.cpp ...
selforg/controller/multilayerffnn.cpp:251:12: warning: %i in format string (no. 1) requires 'int *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
        if(fscanf(f,"%i\n", &layernum) != 1) return false;
           ^
selforg/controller/multilayerffnn.cpp:267:12: warning: %i in format string (no. 1) requires 'int *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
        if(fscanf(f,"%i\n#", &weightsnum) != 1) return false;
           ^
selforg/controller/multilayerffnn.cpp:247:12: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
        if(fscanf(f,"%s\n", buffer) != 1) return false;
           ^
selforg/controller/multilayerffnn.cpp:68:12: style: Local variable 'w' shadows outer variable [shadowVariable]
    Matrix w(layers[i].size, layers[i-1].size);
           ^
selforg/controller/multilayerffnn.cpp:61:10: note: Shadowed declaration
  Matrix w(layers[0].size, inputDim);
         ^
selforg/controller/multilayerffnn.cpp:68:12: note: Shadow variable
    Matrix w(layers[i].size, layers[i-1].size);
           ^
selforg/controller/multilayerffnn.cpp:180:19: style: Local variable 'g_prime' shadows outer variable [shadowVariable]
    const Matrix& g_prime = zs[i].map(layers[i].dactfun);
                  ^
selforg/controller/multilayerffnn.cpp:176:17: note: Shadowed declaration
  const Matrix& g_prime = zs[layernum-1].map(layers[layernum-1].dactfun);
                ^
selforg/controller/multilayerffnn.cpp:180:19: note: Shadow variable
    const Matrix& g_prime = zs[i].map(layers[i].dactfun);
                  ^
selforg/controller/multilayerffnn.cpp:184:19: style: Local variable 'g_prime' shadows outer variable [shadowVariable]
    const Matrix& g_prime = zs[layernum-1].map(layers[layernum-1].dactfun);
                  ^
selforg/controller/multilayerffnn.cpp:176:17: note: Shadowed declaration
  const Matrix& g_prime = zs[layernum-1].map(layers[layernum-1].dactfun);
                ^
selforg/controller/multilayerffnn.cpp:184:19: note: Shadow variable
    const Matrix& g_prime = zs[layernum-1].map(layers[layernum-1].dactfun);
                  ^
selforg/controller/multilayerffnn.cpp:360:5: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    it++;
    ^
27/142 files checked 25% done
Checking selforg/controller/multireinforce.cpp ...
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::number_sensors' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::number_motors' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::x_buffer' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::xp_buffer' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::y_buffer' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::x_context_buffer' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::newaction' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::oldaction' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::state' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::reward' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::oldreward' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::phase' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::phasecnt' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:33:17: warning: Member variable 'MultiReinforce::t' is not initialized in the constructor. [uninitMemberVar]
MultiReinforce::MultiReinforce( const MultiReinforceConf& _conf)
                ^
selforg/controller/multireinforce.cpp:364:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/multireinforce.cpp:399:9: style: The scope of the variable 'file' can be reduced. [variableScope]
  FILE* file;
        ^
selforg/controller/multireinforce.cpp:417:9: style: The scope of the variable 'file' can be reduced. [variableScope]
  FILE* file;
        ^
28/142 files checked 26% done
Checking selforg/controller/mutualinformationcontroller.cpp ...
selforg/controller/mutualinformationcontroller.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/mutualinformationcontroller.cpp:251:51: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
    dS += (((*F)->val(oldState, newState)) + 1) * log(((*F)->val(oldState, newState)) + 1) - (((*F)->val(n, newState))
                                                  ^
selforg/controller/mutualinformationcontroller.cpp:252:16: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
        + 1) * log(((*F)->val(n, newState)) + 1) - (((*F)->val(oldState, n)) + 1) * log(((*F)->val(oldState, n)) + 1);
               ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::sensorNumber' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::motorNumber' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::oldSensorStates' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::MI' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::H_x' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::H_yx' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::H_Xsi' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::ainit' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.cpp:33:30: warning: Member variable 'MutualInformationController::cinit' is not initialized in the constructor. [uninitMemberVar]
MutualInformationController::MutualInformationController(int sensorIntervalCount, double minSensorValue,
                             ^
selforg/controller/mutualinformationcontroller.h:53:3: style: Class 'MutualInformationController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  MutualInformationController(int sensorIntervalCount, double minSensorValue=-1, double maxSensorValue=1, bool showF =false, bool showP =false, bool showXsiF = false);
  ^
selforg/controller/mutualinformationcontroller.h:54:12: style: The destructor '~MutualInformationController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~MutualInformationController() {};
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/mutualinformationcontroller.h:54:12: note: Destructor in derived class
  virtual ~MutualInformationController() {};
           ^
selforg/controller/mutualinformationcontroller.h:100:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/mutualinformationcontroller.h:100:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/mutualinformationcontroller.h:104:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return sensorNumber; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/mutualinformationcontroller.h:104:15: note: Function in derived class
  virtual int getSensorNumber() const { return sensorNumber; }
              ^
selforg/controller/mutualinformationcontroller.h:108:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const { return motorNumber; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/mutualinformationcontroller.h:108:15: note: Function in derived class
  virtual int getMotorNumber() const { return motorNumber; }
              ^
selforg/controller/mutualinformationcontroller.h:117:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/mutualinformationcontroller.h:117:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/mutualinformationcontroller.h:123:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/mutualinformationcontroller.h:123:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/mutualinformationcontroller.h:156:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const { return true; }
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/mutualinformationcontroller.h:156:16: note: Function in derived class
  virtual bool store(FILE* f) const { return true; }
               ^
selforg/controller/mutualinformationcontroller.h:160:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f) { return true; }
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/mutualinformationcontroller.h:160:16: note: Function in derived class
  virtual bool restore(FILE* f) { return true; }
               ^
selforg/controller/mutualinformationcontroller.cpp:101:27: style: C-style pointer casting [cstyleCast]
  this->oldSensorStates = (double*) malloc(sizeof(double) * sensorNumber);
                          ^
selforg/controller/mutualinformationcontroller.cpp:103:14: style: C-style pointer casting [cstyleCast]
  this->MI = (double*) malloc(sizeof(double) * sensorNumber);
             ^
selforg/controller/mutualinformationcontroller.cpp:105:15: style: C-style pointer casting [cstyleCast]
  this->H_x = (double*) malloc(sizeof(double) * sensorNumber);
              ^
selforg/controller/mutualinformationcontroller.cpp:107:16: style: C-style pointer casting [cstyleCast]
  this->H_yx = (double*) malloc(sizeof(double) * sensorNumber);
               ^
selforg/controller/mutualinformationcontroller.cpp:127:19: style: C-style pointer casting [cstyleCast]
    this->H_Xsi = (double*) malloc(sizeof(double) * sensorNumber);
                  ^
selforg/controller/mutualinformationcontroller.cpp:280:11: style: Redundant initialization for 'xsi'. The initialized value is overwritten before it is read. [redundantInitialization]
      xsi = 0.9;
          ^
selforg/controller/mutualinformationcontroller.cpp:278:16: note: xsi is initialized
    double xsi = sensors[i] - ainit * tanh(cinit * this->oldSensorStates[i]);
               ^
selforg/controller/mutualinformationcontroller.cpp:280:11: note: xsi is overwritten
      xsi = 0.9;
          ^
selforg/controller/mutualinformationcontroller.cpp:275:7: style: The scope of the variable 'state' can be reduced. [variableScope]
  int state;
      ^
selforg/controller/mutualinformationcontroller.cpp:254:12: style: Local variable 't' shadows outer variable [shadowVariable]
    double t = (double) (this->t);
           ^
selforg/controller/mutualinformationcontroller.h:199:7: note: Shadowed declaration
  int t; // indicates the step (time)
      ^
selforg/controller/mutualinformationcontroller.cpp:254:12: note: Shadow variable
    double t = (double) (this->t);
           ^
selforg/controller/mutualinformationcontroller.cpp:162:113: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator freqMatrix = freqMatrixList.begin(); freqMatrix != freqMatrixList.end(); freqMatrix++) {
                                                                                                                ^
selforg/controller/mutualinformationcontroller.cpp:184:5: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    pIt++;
    ^
selforg/controller/mutualinformationcontroller.cpp:198:113: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator freqMatrix = freqMatrixList.begin(); freqMatrix != freqMatrixList.end(); freqMatrix++) {
                                                                                                                ^
selforg/controller/mutualinformationcontroller.cpp:239:95: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator F = freqMatrixList.begin(); F != freqMatrixList.end(); F++) {
                                                                                              ^
selforg/controller/mutualinformationcontroller.cpp:276:119: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator freqMatrix = xsiFreqMatrixList.begin(); freqMatrix != xsiFreqMatrixList.end(); freqMatrix++) {
                                                                                                                      ^
selforg/controller/mutualinformationcontroller.cpp:297:101: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator F = xsiFreqMatrixList.begin(); F != xsiFreqMatrixList.end(); F++) {
                                                                                                    ^
selforg/controller/mutualinformationcontroller.cpp:311:95: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator F = freqMatrixList.begin(); F != freqMatrixList.end(); F++) {
                                                                                              ^
selforg/controller/mutualinformationcontroller.cpp:327:95: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator F = freqMatrixList.begin(); F != freqMatrixList.end(); F++) {
                                                                                              ^
selforg/controller/mutualinformationcontroller.cpp:352:95: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (list<matrix::Matrix*>::iterator F = freqMatrixList.begin(); F != freqMatrixList.end(); F++) {
                                                                                              ^
29/142 files checked 28% done
Checking selforg/controller/neuralgas.cpp ...
selforg/controller/neuralgas.cpp:33:12: warning: Member variable 'NeuralGas::maxTime' is not initialized in the constructor. [uninitMemberVar]
NeuralGas::NeuralGas(const std::string& name,
           ^
selforg/controller/neuralgas.h:38:3: style: Class 'NeuralGas' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  NeuralGas(const std::string& name = "NeuralGas", const std::string& revision = "$Id$");
  ^
selforg/controller/neuralgas.h:47:12: style: The destructor '~NeuralGas' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~NeuralGas(){};
           ^
selforg/controller/abstractmodel.h:40:12: note: Virtual destructor in base class
  virtual ~AbstractModel(){};
           ^
selforg/controller/neuralgas.h:47:12: note: Destructor in derived class
  virtual ~NeuralGas(){};
           ^
selforg/controller/neuralgas.h:55:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/abstractmodel.h:50:16: note: Virtual function in base class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/neuralgas.h:55:16: note: Function in derived class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/neuralgas.h:58:32: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/abstractmodel.h:57:32: note: Virtual function in base class
  virtual const matrix::Matrix process (const matrix::Matrix& input)  = 0;
                               ^
selforg/controller/neuralgas.h:58:32: note: Function in derived class
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/neuralgas.h:65:32: style: The function 'learn' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/abstractmodel.h:63:32: note: Virtual function in base class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/neuralgas.h:65:32: note: Function in derived class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/neuralgas.h:69:16: style: The function 'damp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void damp(double damping) { return;}
               ^
selforg/controller/abstractmodel.h:68:16: note: Virtual function in base class
  virtual void damp(double damping)  = 0;
               ^
selforg/controller/neuralgas.h:69:16: note: Function in derived class
  virtual void damp(double damping) { return;}
               ^
selforg/controller/neuralgas.h:71:24: style: The function 'getInputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getInputDim() const { return weights[0].getM();}
                       ^
selforg/controller/abstractmodel.h:71:24: note: Virtual function in base class
  virtual unsigned int getInputDim() const  = 0;
                       ^
selforg/controller/neuralgas.h:71:24: note: Function in derived class
  virtual unsigned int getInputDim() const { return weights[0].getM();}
                       ^
selforg/controller/neuralgas.h:72:24: style: The function 'getOutputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getOutputDim() const  { return weights.size();}
                       ^
selforg/controller/abstractmodel.h:73:24: note: Virtual function in base class
  virtual unsigned int getOutputDim() const  = 0;
                       ^
selforg/controller/neuralgas.h:72:24: note: Function in derived class
  virtual unsigned int getOutputDim() const  { return weights.size();}
                       ^
selforg/controller/neuralgas.h:75:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/neuralgas.h:75:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/neuralgas.h:76:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/neuralgas.h:76:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/neuralgas.cpp:155:3: warning: %i in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  fprintf(f,"%i\n", getOutputDim());
  ^
selforg/controller/neuralgas.cpp:167:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/neuralgas.cpp:169:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/neuralgas.cpp:171:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/neuralgas.cpp:173:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/neuralgas.cpp:76:11: style: C-style pointer casting [cstyleCast]
  fprintf((FILE*)f,"%g ",d);
          ^
30/142 files checked 28% done
Checking selforg/controller/old_stuff/dersimple.cpp ...
selforg/controller/old_stuff/dersimple.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/old_stuff/dersimple.h:57:3: style: Class 'DerSimple' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  DerSimple(const DerSimpleConf& conf = getDefaultConf());
  ^
selforg/controller/old_stuff/dersimple.h:58:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/old_stuff/dersimple.h:58:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/old_stuff/dersimple.h:60:12: style: The destructor '~DerSimple' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~DerSimple();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/old_stuff/dersimple.h:60:12: note: Destructor in derived class
  virtual ~DerSimple();
           ^
selforg/controller/old_stuff/dersimple.h:63:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/old_stuff/dersimple.h:63:15: note: Function in derived class
  virtual int getSensorNumber() const { return number_sensors; }
              ^
selforg/controller/old_stuff/dersimple.h:65:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/old_stuff/dersimple.h:65:15: note: Function in derived class
  virtual int getMotorNumber() const  { return number_motors; }
              ^
selforg/controller/old_stuff/dersimple.h:69:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/old_stuff/dersimple.h:69:16: note: Function in derived class
  virtual void step(const sensor* , int number_sensors, motor* , int number_motors);
               ^
selforg/controller/old_stuff/dersimple.h:72:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/old_stuff/dersimple.h:72:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/old_stuff/dersimple.h:78:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/old_stuff/dersimple.h:78:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/old_stuff/dersimple.h:80:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/old_stuff/dersimple.h:80:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/old_stuff/dersimple.cpp:247:19: style: Local variable 'y' shadows outer variable [shadowVariable]
    const Matrix& y          = y_buffer[(t-s-delay)%buffersize];
                  ^
selforg/controller/old_stuff/dersimple.cpp:208:10: note: Shadowed declaration
  Matrix y = calculateControllerValues(x_smooth - x_smooth_long);//??????????????????????????????????????????????????????????);
         ^
selforg/controller/old_stuff/dersimple.cpp:247:19: note: Shadow variable
    const Matrix& y          = y_buffer[(t-s-delay)%buffersize];
                  ^
selforg/controller/old_stuff/dersimple.cpp:289:21: style: Local variable 'y' shadows outer variable [shadowVariable]
      const Matrix& y = y_buffer[(t)% buffersize]; // eventuell t-1
                    ^
selforg/controller/old_stuff/dersimple.cpp:247:19: note: Shadowed declaration
    const Matrix& y          = y_buffer[(t-s-delay)%buffersize];
                  ^
selforg/controller/old_stuff/dersimple.cpp:289:21: note: Shadow variable
      const Matrix& y = y_buffer[(t)% buffersize]; // eventuell t-1
                    ^
31/142 files checked 30% done
Checking selforg/controller/oneactivemultipassivecontroller.cpp ...
selforg/controller/oneactivemultipassivecontroller.cpp:29:34: warning: Member variable 'OneActiveMultiPassiveController::passiveMotors' is not initialized in the constructor. [uninitMemberVar]
OneActiveMultiPassiveController::OneActiveMultiPassiveController(AbstractController* controller, const std::string& name, const std::string& revision)
                                 ^
selforg/controller/oneactivemultipassivecontroller.h:39:9: style: Class 'OneActiveMultiPassiveController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        OneActiveMultiPassiveController(AbstractController* controller, const std::string& name = "1ActXPassController", const std::string& revision = "$ID$");
        ^
selforg/controller/oneactivemultipassivecontroller.h:41:18: style: The destructor '~OneActiveMultiPassiveController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual ~OneActiveMultiPassiveController();
                 ^
selforg/controller/abstractmulticontroller.h:47:18: note: Virtual destructor in base class
        virtual ~AbstractMultiController();
                 ^
selforg/controller/oneactivemultipassivecontroller.h:41:18: note: Destructor in derived class
        virtual ~OneActiveMultiPassiveController();
                 ^
selforg/controller/oneactivemultipassivecontroller.h:58:22: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
                     ^
selforg/controller/abstractmulticontroller.h:77:22: note: Virtual function in base class
        virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
                     ^
selforg/controller/oneactivemultipassivecontroller.h:58:22: note: Function in derived class
        virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
                     ^
selforg/controller/oneactivemultipassivecontroller.h:68:22: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void step(const sensor* sensors, int sensornumber,
                     ^
selforg/controller/abstractmulticontroller.h:86:22: note: Virtual function in base class
        virtual void step(const sensor* sensors, int sensornumber,
                     ^
selforg/controller/oneactivemultipassivecontroller.h:68:22: note: Function in derived class
        virtual void step(const sensor* sensors, int sensornumber,
                     ^
selforg/controller/oneactivemultipassivecontroller.h:74:22: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void stepNoLearning(const sensor* sensors , int sensornumber,
                     ^
selforg/controller/abstractmulticontroller.h:92:22: note: Virtual function in base class
        virtual void stepNoLearning(const sensor* sensors , int sensornumber,
                     ^
selforg/controller/oneactivemultipassivecontroller.h:74:22: note: Function in derived class
        virtual void stepNoLearning(const sensor* sensors , int sensornumber,
                     ^
selforg/controller/oneactivemultipassivecontroller.h:114:16: style: Class 'OneActiveMultiPassiveController' is unsafe, 'OneActiveMultiPassiveController::passiveMotors' can leak by wrong usage. [unsafeClassCanLeak]
        motor* passiveMotors;
               ^
selforg/controller/oneactivemultipassivecontroller.cpp:49:31: style: C-style pointer casting [cstyleCast]
        this->passiveMotors = (motor*) malloc(sizeof(motor) * motornumber);
                              ^
selforg/controller/oneactivemultipassivecontroller.cpp:58:107: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for(std::list<AbstractController*>::iterator i=controllerList.begin(); i != controllerList.end(); i++){
                                                                                                          ^
selforg/controller/oneactivemultipassivecontroller.cpp:68:107: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for(std::list<AbstractController*>::iterator i=controllerList.begin(); i != controllerList.end(); i++){
                                                                                                          ^
32/142 files checked 30% done
Checking selforg/controller/onecontrollerperchannel.cpp ...
selforg/controller/onecontrollerperchannel.cpp:30:26: warning: Member variable 'OneControllerPerChannel::motornumber' is not initialized in the constructor. [uninitMemberVar]
OneControllerPerChannel::OneControllerPerChannel(ControllerGenerator* controllerGenerator,
                         ^
selforg/controller/onecontrollerperchannel.cpp:30:26: warning: Member variable 'OneControllerPerChannel::sensornumber' is not initialized in the constructor. [uninitMemberVar]
OneControllerPerChannel::OneControllerPerChannel(ControllerGenerator* controllerGenerator,
                         ^
33/142 files checked 31% done
Checking selforg/controller/onelayerffnn.cpp ...
selforg/controller/onelayerffnn.h:15:3: style: Class 'OneLayerFFNN' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  OneLayerFFNN(double eps,
  ^
selforg/controller/onelayerffnn.h:43:12: style: The destructor '~OneLayerFFNN' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~OneLayerFFNN(){ }
           ^
selforg/controller/feedforwardnn.h:47:12: note: Virtual destructor in base class
  virtual ~FeedForwardNN(){};
           ^
selforg/controller/onelayerffnn.h:43:12: note: Destructor in derived class
  virtual ~OneLayerFFNN(){ }
           ^
selforg/controller/onelayerffnn.h:50:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/abstractmodel.h:50:16: note: Virtual function in base class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/onelayerffnn.h:50:16: note: Function in derived class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/onelayerffnn.h:53:32: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/abstractmodel.h:57:32: note: Virtual function in base class
  virtual const matrix::Matrix process (const matrix::Matrix& input)  = 0;
                               ^
selforg/controller/onelayerffnn.h:53:32: note: Function in derived class
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/onelayerffnn.h:55:32: style: The function 'learn' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/abstractmodel.h:63:32: note: Virtual function in base class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/onelayerffnn.h:55:32: note: Function in derived class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/onelayerffnn.h:60:24: style: The function 'getInputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getInputDim() const {
                       ^
selforg/controller/abstractmodel.h:71:24: note: Virtual function in base class
  virtual unsigned int getInputDim() const  = 0;
                       ^
selforg/controller/onelayerffnn.h:60:24: note: Function in derived class
  virtual unsigned int getInputDim() const {
                       ^
selforg/controller/onelayerffnn.h:64:24: style: The function 'getOutputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getOutputDim() const {
                       ^
selforg/controller/abstractmodel.h:73:24: note: Virtual function in base class
  virtual unsigned int getOutputDim() const  = 0;
                       ^
selforg/controller/onelayerffnn.h:64:24: note: Function in derived class
  virtual unsigned int getOutputDim() const {
                       ^
selforg/controller/onelayerffnn.h:72:16: style: The function 'damp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void damp(double damping){
               ^
selforg/controller/feedforwardnn.h:50:16: note: Virtual function in base class
  virtual void damp(double damping) =0 ;
               ^
selforg/controller/onelayerffnn.h:72:16: note: Function in derived class
  virtual void damp(double damping){
               ^
selforg/controller/onelayerffnn.h:79:8: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool store(FILE* f) const;
       ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/onelayerffnn.h:79:8: note: Function in derived class
  bool store(FILE* f) const;
       ^
selforg/controller/onelayerffnn.h:81:8: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  bool restore(FILE* f);
       ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/onelayerffnn.h:81:8: note: Function in derived class
  bool restore(FILE* f);
       ^
selforg/controller/onelayerffnn.cpp:50:12: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
        if(fscanf(f,"%s\n", buffer) != 1) return false;
           ^
34/142 files checked 31% done
Checking selforg/controller/pimax.cpp ...
selforg/controller/pimax.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/pimax.cpp:24:8: warning: Member variable 'PiMax::number_sensors' is not initialized in the constructor. [uninitMemberVar]
PiMax::PiMax(const PiMaxConf& conf_)
       ^
selforg/controller/pimax.cpp:24:8: warning: Member variable 'PiMax::number_motors' is not initialized in the constructor. [uninitMemberVar]
PiMax::PiMax(const PiMaxConf& conf_)
       ^
selforg/controller/pimax.h:64:3: style: Class 'PiMax' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  PiMax(const PiMaxConf& conf = getDefaultConf());
  ^
selforg/controller/pimax.cpp:234:17: style: Local variable 's' shadows outer variable [shadowVariable]
  const Matrix& s       =  s_buffer[(t - 1) % buffersize];
                ^
selforg/controller/pimax.h:149:18: note: Shadowed declaration
  matrix::Matrix s;        // current sensor value vector
                 ^
selforg/controller/pimax.cpp:234:17: note: Shadow variable
  const Matrix& s       =  s_buffer[(t - 1) % buffersize];
                ^
selforg/controller/pimax.cpp:77:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
35/142 files checked 32% done
Checking selforg/controller/qlearning.cpp ...
selforg/controller/qlearning.cpp:36:3: warning: Class 'QLearning' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
  actions  = new int[ringbuffersize];
  ^
selforg/controller/qlearning.cpp:36:3: warning: Class 'QLearning' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
  actions  = new int[ringbuffersize];
  ^
selforg/controller/qlearning.h:47:12: style: The destructor '~QLearning' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~QLearning();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/qlearning.h:47:12: note: Destructor in derived class
  virtual ~QLearning();
           ^
selforg/controller/qlearning.h:113:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/qlearning.h:113:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/qlearning.h:115:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/qlearning.h:115:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/qlearning.cpp:217:83: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(std::list<int>::const_reverse_iterator r=ranges.rbegin(); r!=ranges.rend(); r++){
                                                                                  ^
36/142 files checked 33% done
Checking selforg/controller/semox.cpp ...
selforg/controller/semox.cpp:188:7: style: Boolean value assigned to floating point variable. [assignBoolToFloat]
  pain= xsi_norm > 5*xsi_norm_avg; // pain if large raise in error (arbitrary choice)
      ^
selforg/controller/semox.h:60:3: style: Class 'SeMoX' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  SeMoX(const SeMoXConf& conf = getDefaultConf());
  ^
selforg/controller/semox.cpp:256:21: style: Local variable 'xsi' shadows outer variable [shadowVariable]
      const Matrix& xsi = y_teaching - y;
                    ^
selforg/controller/semox.h:140:18: note: Shadowed declaration
  matrix::Matrix xsi; ///< current output error
                 ^
selforg/controller/semox.cpp:256:21: note: Shadow variable
      const Matrix& xsi = y_teaching - y;
                    ^
37/142 files checked 34% done
Checking selforg/controller/sinecontroller.cpp ...
selforg/controller/sinecontroller.cpp:33:17: warning: Member variable 'SineController::individual' is not initialized in the constructor. [uninitMemberVar]
SineController::SineController(unsigned long int controlmask, function func)
                ^
selforg/controller/sinecontroller.cpp:118:22: warning: Member variable 'MultiSineController::periods' is not initialized in the constructor. [uninitMemberVar]
MultiSineController::MultiSineController(unsigned long int controlmask, function func)
                     ^
selforg/controller/sinecontroller.cpp:118:22: warning: Member variable 'MultiSineController::phaseShifts' is not initialized in the constructor. [uninitMemberVar]
MultiSineController::MultiSineController(unsigned long int controlmask, function func)
                     ^
selforg/controller/sinecontroller.cpp:118:22: warning: Member variable 'MultiSineController::amplitudes' is not initialized in the constructor. [uninitMemberVar]
MultiSineController::MultiSineController(unsigned long int controlmask, function func)
                     ^
selforg/controller/sinecontroller.cpp:118:22: warning: Member variable 'MultiSineController::offsets' is not initialized in the constructor. [uninitMemberVar]
MultiSineController::MultiSineController(unsigned long int controlmask, function func)
                     ^
selforg/controller/sinecontroller.h:99:15: warning: The class 'SineController' defines member variable with name 'name' also defined in its parent class 'Inspectable'. [duplInheritedMember]
  std::string name;
              ^
selforg/utils/inspectable.h:254:13: note: Parent variable 'Inspectable::name'
  iparamkey name;
            ^
selforg/controller/sinecontroller.h:99:15: note: Derived variable 'SineController::name'
  std::string name;
              ^
selforg/controller/sinecontroller.h:45:3: style: Class 'SineController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  SineController(unsigned long int controlmask = (~0), function func = Sine);
  ^
selforg/controller/sinecontroller.h:116:3: style: Class 'MultiSineController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  MultiSineController(unsigned long int controlmask = (~0), function func = Sine);
  ^
selforg/controller/sinecontroller.h:50:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/sinecontroller.h:50:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/sinecontroller.h:54:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const {return number_sensors;}
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/sinecontroller.h:54:15: note: Function in derived class
  virtual int getSensorNumber() const {return number_sensors;}
              ^
selforg/controller/sinecontroller.h:59:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const {return number_motors;}
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/sinecontroller.h:59:15: note: Function in derived class
  virtual int getMotorNumber() const {return number_motors;}
              ^
selforg/controller/sinecontroller.h:68:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/sinecontroller.h:68:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/sinecontroller.h:73:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/sinecontroller.h:73:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/sinecontroller.h:79:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const {
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/sinecontroller.h:79:16: note: Function in derived class
  virtual bool store(FILE* f) const {
               ^
selforg/controller/sinecontroller.h:85:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f) {
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/sinecontroller.h:85:16: note: Function in derived class
  virtual bool restore(FILE* f) {
               ^
selforg/controller/sinecontroller.h:117:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/sinecontroller.h:50:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/sinecontroller.h:117:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/sinecontroller.h:118:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/sinecontroller.h:73:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/sinecontroller.h:118:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
38/142 files checked 34% done
Checking selforg/controller/som.cpp ...
selforg/controller/som.cpp:31:6: warning: Member variable 'SOM::rbfsize' is not initialized in the constructor. [uninitMemberVar]
SOM::SOM(const std::string& name, const std::string& revision) : AbstractModel(name, revision) {
     ^
selforg/controller/som.cpp:31:6: warning: Member variable 'SOM::size' is not initialized in the constructor. [uninitMemberVar]
SOM::SOM(const std::string& name, const std::string& revision) : AbstractModel(name, revision) {
     ^
selforg/controller/som.cpp:38:6: warning: Member variable 'SOM::size' is not initialized in the constructor. [uninitMemberVar]
SOM::SOM(unsigned int dimensions, double sigma, double eps, double rbfsize,
     ^
selforg/controller/som.h:41:3: style: Class 'SOM' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  SOM(const std::string& name="SOM",
  ^
selforg/controller/som.h:50:12: style: The destructor '~SOM' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~SOM(){};
           ^
selforg/controller/abstractmodel.h:40:12: note: Virtual destructor in base class
  virtual ~AbstractModel(){};
           ^
selforg/controller/som.h:50:12: note: Destructor in derived class
  virtual ~SOM(){};
           ^
selforg/controller/som.h:58:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/abstractmodel.h:50:16: note: Virtual function in base class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/som.h:58:16: note: Function in derived class
  virtual void init(unsigned int inputDim, unsigned  int outputDim,
               ^
selforg/controller/som.h:61:32: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/abstractmodel.h:57:32: note: Virtual function in base class
  virtual const matrix::Matrix process (const matrix::Matrix& input)  = 0;
                               ^
selforg/controller/som.h:61:32: note: Function in derived class
  virtual const matrix::Matrix process (const matrix::Matrix& input);
                               ^
selforg/controller/som.h:68:32: style: The function 'learn' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/abstractmodel.h:63:32: note: Virtual function in base class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/som.h:68:32: note: Function in derived class
  virtual const matrix::Matrix learn (const matrix::Matrix& input,
                               ^
selforg/controller/som.h:72:16: style: The function 'damp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void damp(double damping) { return;}
               ^
selforg/controller/abstractmodel.h:68:16: note: Virtual function in base class
  virtual void damp(double damping)  = 0;
               ^
selforg/controller/som.h:72:16: note: Function in derived class
  virtual void damp(double damping) { return;}
               ^
selforg/controller/som.h:74:24: style: The function 'getInputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getInputDim() const { return weights[0].getM();}
                       ^
selforg/controller/abstractmodel.h:71:24: note: Virtual function in base class
  virtual unsigned int getInputDim() const  = 0;
                       ^
selforg/controller/som.h:74:24: note: Function in derived class
  virtual unsigned int getInputDim() const { return weights[0].getM();}
                       ^
selforg/controller/som.h:75:24: style: The function 'getOutputDim' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual unsigned int getOutputDim() const  { return weights.size();}
                       ^
selforg/controller/abstractmodel.h:73:24: note: Virtual function in base class
  virtual unsigned int getOutputDim() const  = 0;
                       ^
selforg/controller/som.h:75:24: note: Function in derived class
  virtual unsigned int getOutputDim() const  { return weights.size();}
                       ^
selforg/controller/som.h:78:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/som.h:78:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/som.h:79:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/som.h:79:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/som.cpp:194:3: warning: %i in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  fprintf(f,"%i\n", getOutputDim());
  ^
selforg/controller/som.cpp:205:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/som.cpp:207:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/som.cpp:209:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/som.cpp:211:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/som.cpp:213:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/controller/som.cpp:79:22: style: C-style pointer casting [cstyleCast]
  return exp(- d*d/ *(double*)rdfsize);
                     ^
selforg/controller/som.cpp:148:11: style: C-style pointer casting [cstyleCast]
  fprintf((FILE*)f,"%g ",d);
          ^
selforg/controller/som.cpp:76:38: style: Parameter 'rdfsize' can be declared as pointer to const. However it seems that 'activationfunction' is a callback function, if 'rdfsize' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
double SOM::activationfunction(void* rdfsize, double d){
                                     ^
selforg/controller/som.cpp:167:35: note: You might need to cast the function pointer here
  return distances.mapP(&rbfsize, activationfunction);
                                  ^
selforg/controller/som.cpp:76:38: note: Parameter 'rdfsize' can be declared as pointer to const
double SOM::activationfunction(void* rdfsize, double d){
                                     ^
39/142 files checked 35% done
Checking selforg/controller/soml.cpp ...
selforg/controller/soml.cpp:25:7: warning: Member variable 'SoML::number_sensors' is not initialized in the constructor. [uninitMemberVar]
SoML::SoML(const SoMLConf& conf)
      ^
selforg/controller/soml.cpp:25:7: warning: Member variable 'SoML::number_motors' is not initialized in the constructor. [uninitMemberVar]
SoML::SoML(const SoMLConf& conf)
      ^
selforg/controller/soml.cpp:25:7: warning: Member variable 'SoML::numControllerLayer' is not initialized in the constructor. [uninitMemberVar]
SoML::SoML(const SoMLConf& conf)
      ^
selforg/controller/soml.cpp:25:7: warning: Member variable 'SoML::E' is not initialized in the constructor. [uninitMemberVar]
SoML::SoML(const SoMLConf& conf)
      ^
selforg/controller/soml.h:52:3: style: Class 'SoML' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  SoML(const SoMLConf& conf = getDefaultConf());
  ^
selforg/controller/soml.cpp:199:19: style: Local variable 'y' shadows outer argument [shadowArgument]
    const Matrix& y     = cNet->getLayerOutput(l);
                  ^
selforg/controller/soml.cpp:167:49: note: Shadowed declaration
void SoML::learn(const Matrix& x, const Matrix& y){
                                                ^
selforg/controller/soml.cpp:199:19: note: Shadow variable
    const Matrix& y     = cNet->getLayerOutput(l);
                  ^
40/142 files checked 36% done
Checking selforg/controller/sos.cpp ...
selforg/controller/sos.cpp:24:6: warning: Member variable 'Sos::number_sensors' is not initialized in the constructor. [uninitMemberVar]
Sos::Sos(double init_feedback_strength)
     ^
selforg/controller/sos.cpp:24:6: warning: Member variable 'Sos::number_motors' is not initialized in the constructor. [uninitMemberVar]
Sos::Sos(double init_feedback_strength)
     ^
selforg/controller/sos.h:37:3: style: Class 'Sos' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Sos(double init_feedback_strength = 1.0);
  ^
selforg/controller/sos.cpp:156:17: style: Local variable 'x' shadows outer variable [shadowVariable]
  const Matrix& x = x_buffer[(t - max(s4delay,1) + buffersize) % buffersize];
                ^
selforg/controller/sos.h:84:18: note: Shadowed declaration
  matrix::Matrix x;        // current sensor value vector
                 ^
selforg/controller/sos.cpp:156:17: note: Shadow variable
  const Matrix& x = x_buffer[(t - max(s4delay,1) + buffersize) % buffersize];
                ^
selforg/controller/sos.cpp:51:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
41/142 files checked 37% done
Checking selforg/controller/sox.cpp ...
selforg/controller/sox.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/sox.h:60:3: style: Class 'Sox' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Sox(const SoxConf& conf = getDefaultConf());
  ^
selforg/controller/sox.h:63:3: style: Class 'Sox' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Sox(double init_feedback_strength, bool useExtendedModel = true,
  ^
selforg/controller/sox.cpp:263:17: style: Local variable 'x' shadows outer variable [shadowVariable]
  const Matrix& x       = x_buffer[(t - max(s4delay,1) + buffersize) % buffersize];
                ^
selforg/controller/sox.h:146:18: note: Shadowed declaration
  matrix::Matrix x;        // current sensor value vector
                 ^
selforg/controller/sox.cpp:263:17: note: Shadow variable
  const Matrix& x       = x_buffer[(t - max(s4delay,1) + buffersize) % buffersize];
                ^
selforg/controller/sox.cpp:315:21: style: Local variable 'y' shadows outer variable [shadowVariable]
      const Matrix& y      = y_buffer[(t-1)% buffersize];
                    ^
selforg/controller/sox.cpp:270:17: note: Shadowed declaration
  const Matrix& y       = z.map(g);
                ^
selforg/controller/sox.cpp:315:21: note: Shadow variable
      const Matrix& y      = y_buffer[(t-1)% buffersize];
                    ^
selforg/controller/sox.cpp:97:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
42/142 files checked 38% done
Checking selforg/controller/soxexpand.cpp ...
selforg/controller/soxexpand.h:49:3: style: Class 'SoxExpand' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  SoxExpand(const SoxExpandConf& conf = getDefaultConf());
  ^
selforg/controller/soxexpand.cpp:195:17: style: Local variable 'x' shadows outer variable [shadowVariable]
  const Matrix& x = x_buffer[(t - max(s4delay,1) + buffersize) % buffersize];
                ^
selforg/controller/soxexpand.h:112:18: note: Shadowed declaration
  matrix::Matrix x;        // current sensor value vector
                 ^
selforg/controller/soxexpand.cpp:195:17: note: Shadow variable
  const Matrix& x = x_buffer[(t - max(s4delay,1) + buffersize) % buffersize];
                ^
selforg/controller/soxexpand.cpp:62:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
43/142 files checked 38% done
Checking selforg/controller/splitcontrol.cpp ...
selforg/controller/splitcontrol.cpp:30:15: warning: Member variable 'SplitControl::motornumber' is not initialized in the constructor. [uninitMemberVar]
SplitControl::SplitControl(ControllerGenerator* controllerGenerator,
              ^
selforg/controller/splitcontrol.cpp:30:15: warning: Member variable 'SplitControl::sensornumber' is not initialized in the constructor. [uninitMemberVar]
SplitControl::SplitControl(ControllerGenerator* controllerGenerator,
              ^
selforg/controller/splitcontrol.cpp:30:15: warning: Member variable 'SplitControl::sensorbuffer' is not initialized in the constructor. [uninitMemberVar]
SplitControl::SplitControl(ControllerGenerator* controllerGenerator,
              ^
selforg/controller/splitcontrol.cpp:30:15: warning: Member variable 'SplitControl::motorbuffer' is not initialized in the constructor. [uninitMemberVar]
SplitControl::SplitControl(ControllerGenerator* controllerGenerator,
              ^
44/142 files checked 39% done
Checking selforg/controller/switchcontroller.cpp ...
selforg/controller/switchcontroller.h:36:3: style: Class 'SwitchController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  SwitchController(const std::list<AbstractController*>& controllers, const std::string& name = "SwitchController", const std::string& revision = "1.0");
  ^
selforg/controller/switchcontroller.h:38:12: style: The destructor '~SwitchController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~SwitchController();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/switchcontroller.h:38:12: note: Destructor in derived class
  virtual ~SwitchController();
           ^
selforg/controller/switchcontroller.h:40:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/switchcontroller.h:40:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/switchcontroller.h:41:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/switchcontroller.h:41:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/switchcontroller.h:43:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/switchcontroller.h:43:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* sensors , int sensornumber,
               ^
selforg/controller/switchcontroller.h:46:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const { return controllers.front()->getSensorNumber();};
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/switchcontroller.h:46:15: note: Function in derived class
  virtual int getSensorNumber() const { return controllers.front()->getSensorNumber();};
              ^
selforg/controller/switchcontroller.h:48:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const { return controllers.front()->getMotorNumber();};
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/switchcontroller.h:48:15: note: Function in derived class
  virtual int getMotorNumber() const { return controllers.front()->getMotorNumber();};
              ^
selforg/controller/switchcontroller.h:51:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const { return controllers.front()->store(f);};
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/switchcontroller.h:51:16: note: Function in derived class
  virtual bool store(FILE* f) const { return controllers.front()->store(f);};
               ^
selforg/controller/switchcontroller.h:52:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f)     { return controllers.front()->restore(f);};
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/switchcontroller.h:52:16: note: Function in derived class
  virtual bool restore(FILE* f)     { return controllers.front()->restore(f);};
               ^
selforg/controller/switchcontroller.cpp:51:18: style: C-style pointer casting [cstyleCast]
  motor* dummy = (motor*) malloc(sizeof(motor) * motornumber);
                 ^
selforg/controller/switchcontroller.cpp:66:18: style: C-style pointer casting [cstyleCast]
  motor* dummy = (motor*) malloc(sizeof(motor) * motornumber);
                 ^
45/142 files checked 39% done
Checking selforg/controller/universalcontroller.cpp ...
selforg/controller/universalcontroller.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/universalcontroller.cpp:33:22: warning: Member variable 'UniversalController::x_buffer' is not initialized in the constructor. [uninitMemberVar]
UniversalController::UniversalController(const UniversalControllerConf& conf)
                     ^
selforg/controller/universalcontroller.cpp:33:22: warning: Member variable 'UniversalController::y_buffer' is not initialized in the constructor. [uninitMemberVar]
UniversalController::UniversalController(const UniversalControllerConf& conf)
                     ^
selforg/controller/universalcontroller.cpp:33:22: warning: Member variable 'UniversalController::v_buffer' is not initialized in the constructor. [uninitMemberVar]
UniversalController::UniversalController(const UniversalControllerConf& conf)
                     ^
selforg/controller/universalcontroller.h:53:3: style: Class 'UniversalController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  UniversalController(const UniversalControllerConf& conf = getDefaultConf());
  ^
selforg/controller/universalcontroller.h:54:12: style: The destructor '~UniversalController' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~UniversalController();
           ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/universalcontroller.h:54:12: note: Destructor in derived class
  virtual ~UniversalController();
           ^
selforg/controller/universalcontroller.h:80:16: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/abstractcontroller.h:58:16: note: Virtual function in base class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = nullptr)= 0;
               ^
selforg/controller/universalcontroller.h:80:16: note: Function in derived class
  virtual void init(int sensornumber, int motornumber, RandGen* randGen = 0);
               ^
selforg/controller/universalcontroller.h:82:15: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getSensorNumber() const {return number_sensors;}
              ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/universalcontroller.h:82:15: note: Function in derived class
  virtual int getSensorNumber() const {return number_sensors;}
              ^
selforg/controller/universalcontroller.h:84:15: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getMotorNumber() const {return number_motors;}
              ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/universalcontroller.h:84:15: note: Function in derived class
  virtual int getMotorNumber() const {return number_motors;}
              ^
selforg/controller/universalcontroller.h:86:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/universalcontroller.h:86:16: note: Function in derived class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/universalcontroller.h:89:16: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/universalcontroller.h:89:16: note: Function in derived class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/universalcontroller.h:126:16: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool store(FILE* f) const;
               ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/universalcontroller.h:126:16: note: Function in derived class
  virtual bool store(FILE* f) const;
               ^
selforg/controller/universalcontroller.h:127:16: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool restore(FILE* f);
               ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/universalcontroller.h:127:16: note: Function in derived class
  virtual bool restore(FILE* f);
               ^
selforg/controller/universalcontroller.cpp:62:24: style: Variable 'randGen' is assigned a value that is never used. [unreadVariable]
  if(!randGen) randGen = new RandGen(); // this gives a small memory leak
                       ^
46/142 files checked 40% done
Checking selforg/controller/use_java_controller.cpp ...
selforg/controller/use_java_controller.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::number_sensors' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::number_motors' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::serverOK' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::anz_config_param' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::anz_internal_param' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::can_send' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::isFirst' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::isClosed' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::server_guilogger_isClosed' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::server_controller_isClosed' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::anzahl_closed_Server' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.cpp:37:22: warning: Member variable 'use_java_controller::motor_values_alt' is not initialized in the constructor. [uninitMemberVar]
use_java_controller::use_java_controller ( const char* port_controller, const char* port_internalParams, const char* name )
                     ^
selforg/controller/use_java_controller.h:146:29: warning: The class 'use_java_controller' defines member variable with name 'name' also defined in its parent class 'Inspectable'. [duplInheritedMember]
                const char* name;
                            ^
selforg/utils/inspectable.h:254:13: note: Parent variable 'Inspectable::name'
  iparamkey name;
            ^
selforg/controller/use_java_controller.h:146:29: note: Derived variable 'use_java_controller::name'
                const char* name;
                            ^
selforg/controller/use_java_controller.h:75:17: style: Class 'use_java_controller' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
                use_java_controller ( const char* port_controller = "4444", const char* port_internalParams = NULL, const char* name = "defaultRobot" );
                ^
selforg/controller/use_java_controller.h:81:26: style: The destructor '~use_java_controller' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
                virtual ~use_java_controller();
                         ^
selforg/utils/configurable.h:156:14: note: Virtual destructor in base class
    virtual ~Configurable()
             ^
selforg/controller/use_java_controller.h:81:26: note: Destructor in derived class
                virtual ~use_java_controller();
                         ^
selforg/controller/use_java_controller.h:90:29: style: The function 'getSensorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
                virtual int getSensorNumber() const {return number_sensors;}
                            ^
selforg/controller/abstractcontroller.h:62:15: note: Virtual function in base class
  virtual int getSensorNumber() const= 0;
              ^
selforg/controller/use_java_controller.h:90:29: note: Function in derived class
                virtual int getSensorNumber() const {return number_sensors;}
                            ^
selforg/controller/use_java_controller.h:95:29: style: The function 'getMotorNumber' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
                virtual int getMotorNumber() const {return number_motors;}
                            ^
selforg/controller/abstractcontroller.h:66:15: note: Virtual function in base class
  virtual int getMotorNumber() const= 0;
              ^
selforg/controller/use_java_controller.h:95:29: note: Function in derived class
                virtual int getMotorNumber() const {return number_motors;}
                            ^
selforg/controller/use_java_controller.h:104:30: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
                virtual void step ( const sensor* sensors, int sensornumber,
                             ^
selforg/controller/abstractcontroller.h:75:16: note: Virtual function in base class
  virtual void step(const sensor* sensors, int sensornumber,
               ^
selforg/controller/use_java_controller.h:104:30: note: Function in derived class
                virtual void step ( const sensor* sensors, int sensornumber,
                             ^
selforg/controller/use_java_controller.h:109:30: style: The function 'stepNoLearning' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
                virtual void stepNoLearning ( const sensor* , int number_sensors,
                             ^
selforg/controller/abstractcontroller.h:80:16: note: Virtual function in base class
  virtual void stepNoLearning(const sensor* , int number_sensors,
               ^
selforg/controller/use_java_controller.h:109:30: note: Function in derived class
                virtual void stepNoLearning ( const sensor* , int number_sensors,
                             ^
selforg/controller/use_java_controller.h:139:30: style: The function 'store' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
                virtual bool store   ( FILE* f ) const { return true;};  // FIXME: store Parameter
                             ^
selforg/utils/storeable.h:38:16: note: Virtual function in base class
  virtual bool store(FILE* f) const = 0;
               ^
selforg/controller/use_java_controller.h:139:30: note: Function in derived class
                virtual bool store   ( FILE* f ) const { return true;};  // FIXME: store Parameter
                             ^
selforg/controller/use_java_controller.h:140:30: style: The function 'restore' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
                virtual bool restore ( FILE* f )       { return true;};  // FIXME: restore Parameter
                             ^
selforg/utils/storeable.h:42:16: note: Virtual function in base class
  virtual bool restore(FILE* f) = 0;
               ^
selforg/controller/use_java_controller.h:140:30: note: Function in derived class
                virtual bool restore ( FILE* f )       { return true;};  // FIXME: restore Parameter
                             ^
selforg/controller/use_java_controller.cpp:113:1: error: Memory leak: port_iP [memleak]
};
^
selforg/controller/use_java_controller.cpp:46:21: style: C-style pointer casting [cstyleCast]
          port_iP = ( char* )  malloc ( 64 * sizeof(char) );
                    ^
selforg/controller/use_java_controller.cpp:81:44: style: C-style pointer casting [cstyleCast]
        if ( ::bind ( server_controller, ( struct sockaddr* ) &server_controller_addr, sizeof ( server_controller_addr ) ) == -1 )
                                           ^
selforg/controller/use_java_controller.cpp:83:48: style: C-style pointer casting [cstyleCast]
        if ( ::bind ( server_internalParams, ( struct sockaddr* ) &server_internalParams_addr, sizeof ( server_internalParams_addr ) ) == -1 )
                                               ^
selforg/controller/use_java_controller.cpp:99:59: style: C-style pointer casting [cstyleCast]
        client_controller = accept ( server_controller, ( struct sockaddr* ) &client_controller_addr, &client_controller_size );
                                                          ^
selforg/controller/use_java_controller.cpp:107:67: style: C-style pointer casting [cstyleCast]
        client_internalParams = accept ( server_internalParams, ( struct sockaddr* ) &client_internalParams_addr, &client_internalParams_size );
                                                                  ^
selforg/controller/use_java_controller.cpp:160:21: style: C-style pointer casting [cstyleCast]
        temp_init = ( char* )  malloc ( BUFFER_SIZE );
                    ^
selforg/controller/use_java_controller.cpp:294:28: style: C-style pointer casting [cstyleCast]
        motor_values_alt = ( double* ) malloc ( motornumber*sizeof ( double ) );
                           ^
selforg/controller/use_java_controller.cpp:329:21: style: C-style pointer casting [cstyleCast]
            temp =  ( char* )  malloc ( BUFFER_SIZE );
                    ^
selforg/controller/use_java_controller.cpp:330:21: style: C-style pointer casting [cstyleCast]
            temp1 = ( char* )  malloc ( BUFFER_SIZE );
                    ^
selforg/controller/use_java_controller.cpp:530:40: style: C-style pointer casting [cstyleCast]
                                temp = ( char* )  malloc ( BUFFER_SIZE );
                                       ^
selforg/controller/use_java_controller.cpp:421:32: style: Variable 'motors' is assigned a value that is never used. [unreadVariable]
                        motors = motor_values_alt;
                               ^
47/142 files checked 42% done
Checking selforg/examples/controllertest.cpp ...
selforg/examples/controllertest.cpp:6:0: information: Include file: "selforg/sinecontroller.h" not found. [missingInclude]
#include "selforg/sinecontroller.h"
^
selforg/examples/controllertest.cpp:7:0: information: Include file: "selforg/invertmotorspace.h" not found. [missingInclude]
#include "selforg/invertmotorspace.h"
^
selforg/examples/controllertest.cpp:8:0: information: Include file: "selforg/invertmotornstep.h" not found. [missingInclude]
#include "selforg/invertmotornstep.h"
^
selforg/examples/controllertest.cpp:9:0: information: Include file: "selforg/invertmotorbigmodel.h" not found. [missingInclude]
#include "selforg/invertmotorbigmodel.h"
^
selforg/examples/controllertest.cpp:10:0: information: Include file: "selforg/multilayerffnn.h" not found. [missingInclude]
#include "selforg/multilayerffnn.h"
^
selforg/examples/controllertest.cpp:11:0: information: Include file: "selforg/dercontroller.h" not found. [missingInclude]
#include "selforg/dercontroller.h"
^
48/142 files checked 42% done
Checking selforg/examples/directconnect/directconnect.cpp ...
49/142 files checked 42% done
Checking selforg/examples/feedforwardtest.cpp ...
selforg/examples/feedforwardtest.cpp:307:6: style: Condition 'mltests' is always false [knownConditionTrueFalse]
  if(mltests){
     ^
selforg/examples/feedforwardtest.cpp:303:18: note: Assignment 'mltests=false', assigned value is 0
  bool mltests = false;
                 ^
selforg/examples/feedforwardtest.cpp:307:6: note: Condition 'mltests' is always false
  if(mltests){
     ^
selforg/examples/feedforwardtest.cpp:347:6: style: Condition 'somtests' is always false [knownConditionTrueFalse]
  if(somtests){
     ^
selforg/examples/feedforwardtest.cpp:304:19: note: Assignment 'somtests=false', assigned value is 0
  bool somtests = false;
                  ^
selforg/examples/feedforwardtest.cpp:347:6: note: Condition 'somtests' is always false
  if(somtests){
     ^
selforg/examples/feedforwardtest.cpp:356:6: style: Condition 'contrtests' is always true [knownConditionTrueFalse]
  if(contrtests){
     ^
selforg/examples/feedforwardtest.cpp:305:21: note: Assignment 'contrtests=true', assigned value is 1
  bool contrtests = true;
                    ^
selforg/examples/feedforwardtest.cpp:356:6: note: Condition 'contrtests' is always true
  if(contrtests){
     ^
50/142 files checked 43% done
Checking selforg/examples/integration/cmdline.cpp ...
selforg/examples/integration/cmdline.cpp:12:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
selforg/examples/integration/cmdline.cpp:31:69: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    for(ConfigList::iterator i=configs.begin(); i != configs.end(); i++){
                                                                    ^
selforg/examples/integration/cmdline.cpp:41:58: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(string::const_iterator i=str.begin(); i<str.end(); i++){
                                                         ^
selforg/examples/integration/cmdline.cpp:48:11: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
          i++;
          ^
51/142 files checked 43% done
Checking selforg/examples/integration/main.cpp ...
selforg/examples/integration/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/examples/integration/main.cpp:23:5: performance: Variable 'myparam' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    myparam=0;
    ^
52/142 files checked 44% done
Checking selforg/examples/matrix/matrixexample.cpp ...
53/142 files checked 44% done
Checking selforg/examples/rl_test.cpp ...
selforg/examples/rl_test.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
54/142 files checked 44% done
Checking selforg/matrix/benchmark_matrix.cpp ...
selforg/matrix/benchmark_matrix.cpp:94:76: error: syntax error: +) [syntaxError]
            std::cout << std::setw(10) << (std::to_stringstatic_cast<size>(+) "x" + std::to_string(size))
                                                                           ^
Checking selforg/matrix/benchmark_matrix.cpp: USE_ARM64_NEON...
selforg/matrix/benchmark_matrix.cpp:88:76: error: syntax error: +) [syntaxError]
            std::cout << std::setw(10) << (std::to_stringstatic_cast<size>(+) "x" + std::to_string(size))
                                                                           ^
Checking selforg/matrix/benchmark_matrix.cpp: __ARM_NEON...
Checking selforg/matrix/benchmark_matrix.cpp: __aarch64__...
55/142 files checked 45% done
Checking selforg/matrix/matrix.cpp ...
selforg/matrix/matrix.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/matrix/matrix.cpp:180:5: warning: %i in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    fprintf ( f, "MATRIX %i %i\n", m, n );
    ^
selforg/matrix/matrix.cpp:180:5: warning: %i in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    fprintf ( f, "MATRIX %i %i\n", m, n );
    ^
selforg/matrix/matrix.cpp:199:12: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
      if ( fscanf ( f, "%s ", buffer ) != 1 ) return false;
           ^
selforg/matrix/matrix.cpp:567:5: error: Common realloc mistake: 'data' nulled but not freed upon failure [memleakOnRealloc]
    data = ( D* ) realloc ( data, sizeof ( D ) * ( this->m * this->n + a.n * a.m ) );
    ^
selforg/matrix/matrix.cpp:261:11: warning: If memory allocation fails, then there is a possible null pointer dereference: newdata [nullPointerOutOfMemory]
          newdata[j*m+i] = data[i*n+j];
          ^
selforg/matrix/matrix.cpp:258:39: note: Assuming allocation function fails
      double* newdata = ( D* ) malloc ( sizeof ( D ) * buffersize );
                                      ^
selforg/matrix/matrix.cpp:258:25: note: Assignment 'newdata=(double*)malloc(sizeof(double)*buffersize)', assigned value is 0
      double* newdata = ( D* ) malloc ( sizeof ( D ) * buffersize );
                        ^
selforg/matrix/matrix.cpp:261:11: note: Null pointer dereference
          newdata[j*m+i] = data[i*n+j];
          ^
selforg/matrix/matrix.cpp:72:14: style: C-style pointer casting [cstyleCast]
      data = ( D* ) malloc ( sizeof ( D ) * buffersize );
             ^
selforg/matrix/matrix.cpp:258:25: style: C-style pointer casting [cstyleCast]
      double* newdata = ( D* ) malloc ( sizeof ( D ) * buffersize );
                        ^
selforg/matrix/matrix.cpp:567:12: style: C-style pointer casting [cstyleCast]
    data = ( D* ) realloc ( data, sizeof ( D ) * ( this->m * this->n + a.n * a.m ) );
           ^
selforg/matrix/matrix.cpp:580:12: style: C-style pointer casting [cstyleCast]
    data = ( D* ) malloc(sizeof ( D ) * buffersize );
           ^
selforg/matrix/matrix.cpp:599:16: style: C-style pointer casting [cstyleCast]
    return * ( ( double* ) a ) < * ( ( double* ) b ) ? -1 : ( * ( ( double* ) a ) > * ( ( double* ) b ) ? 1 : 0 );
               ^
selforg/matrix/matrix.cpp:746:12: style: C-style pointer casting [cstyleCast]
    data = ( D* ) malloc ( sizeof ( D ) * m * newN );
           ^
selforg/matrix/matrix.cpp:360:12: style: Local variable 'copy' shadows outer function [shadowFunction]
    Matrix copy(*this);
           ^
selforg/matrix/matrix.h:325:10: note: Shadowed declaration
    void copy(const Matrix& c){ // Deep copy
         ^
selforg/matrix/matrix.cpp:360:12: note: Shadow variable
    Matrix copy(*this);
           ^
selforg/matrix/matrix.cpp:406:18: style: Local variable 'm' shadows outer variable [shadowVariable]
          Matrix m(*this);
                 ^
selforg/matrix/matrix.h:451:7: note: Shadowed declaration
    I m, n;
      ^
selforg/matrix/matrix.cpp:406:18: note: Shadow variable
          Matrix m(*this);
                 ^
selforg/matrix/matrix.cpp:891:8: style: Variable 'p1' can be declared as pointer to const [constVariablePointer]
    D* p1 = data;
       ^
selforg/matrix/matrix.cpp:892:8: style: Variable 'p2' can be declared as pointer to const [constVariablePointer]
    D* p2 = c.data;
       ^
selforg/matrix/matrix.tests.hpp:178:0: error: failed to expand 'unit_assert', Wrong number of parameters for macro 'unit_assert'. [preprocessorErrorDirective]
  unit_assert( "expstatic_cast<T>(=transpose"), M3 == M4 );
^
Checking selforg/matrix/matrix.cpp: WIN32...
selforg/matrix/matrix.cpp:92:21: style: C-style pointer casting [cstyleCast]
    const char* a = (char*) _a;
                    ^
selforg/matrix/matrix.cpp:93:21: style: C-style pointer casting [cstyleCast]
    const char* b = (char*) _b;
                    ^
56/142 files checked 47% done
Checking selforg/matrix/matrix_neon.cpp ...
Checking selforg/matrix/matrix_neon.cpp: __ARM_NEON...
selforg/matrix/matrix_neon.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/matrix/matrix_neon.h:64:31: style: Unused private function: 'MatrixNEON::add4_f64' [unusedPrivateFunction]
    static inline float64x2_t add4_f64(float64x2_t a, float64x2_t b,
                              ^
57/142 files checked 47% done
Checking selforg/matrix/matrixutils.cpp ...
selforg/matrix/matrixutils.cpp:126:27: style: Same expression on both sides of '=='. [duplicateExpression]
    assert(sizeof(double) == sizeof(D));
                          ^
Checking selforg/matrix/matrixutils.cpp: NO_GSL...
selforg/matrix/matrixutils.cpp:202:59: style: Parameter 'eigenvalues' can be declared as reference to const [constParameterReference]
  bool eigenValuesVectorsRealSym(const Matrix &m, Matrix& eigenvalues,
                                                          ^
selforg/matrix/matrixutils.cpp:203:42: style: Parameter 'eigenvectors' can be declared as reference to const [constParameterReference]
                                 Matrix& eigenvectors){
                                         ^
selforg/matrix/matrixutils.cpp:208:45: style: Parameter 'real' can be declared as reference to const [constParameterReference]
  bool eigenValues(const Matrix &m, Matrix& real, Matrix& imag){
                                            ^
selforg/matrix/matrixutils.cpp:208:59: style: Parameter 'imag' can be declared as reference to const [constParameterReference]
  bool eigenValues(const Matrix &m, Matrix& real, Matrix& imag){
                                                          ^
selforg/matrix/matrixutils.cpp:213:52: style: Parameter 'vals_real' can be declared as reference to const [constParameterReference]
  bool eigenValuesVectors(const Matrix &m, Matrix& vals_real, Matrix& vals_imag,
                                                   ^
selforg/matrix/matrixutils.cpp:213:71: style: Parameter 'vals_imag' can be declared as reference to const [constParameterReference]
  bool eigenValuesVectors(const Matrix &m, Matrix& vals_real, Matrix& vals_imag,
                                                                      ^
selforg/matrix/matrixutils.cpp:214:35: style: Parameter 'vecs_real' can be declared as reference to const [constParameterReference]
                          Matrix& vecs_real, Matrix& vecs_imag){
                                  ^
selforg/matrix/matrixutils.cpp:214:54: style: Parameter 'vecs_imag' can be declared as reference to const [constParameterReference]
                          Matrix& vecs_real, Matrix& vecs_imag){
                                                     ^
58/142 files checked 48% done
Checking selforg/matrix/sse_test.cc ...
59/142 files checked 48% done
Checking selforg/matrix/test_matrix.cpp ...
selforg/matrix/test_matrix.cpp:182:14: warning: Assert statement calls a function which may have desired side effects: 'read'. [assertWithSideEffect]
    assert(b.read(f));
             ^
60/142 files checked 49% done
Checking selforg/simulations/dblcontingency/cmdline.cpp ...
selforg/simulations/dblcontingency/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
61/142 files checked 49% done
Checking selforg/simulations/dblcontingency/console.cpp ...
selforg/simulations/dblcontingency/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/dblcontingency/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/dblcontingency/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/dblcontingency/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/dblcontingency/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/dblcontingency/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/dblcontingency/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/dblcontingency/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/dblcontingency/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/dblcontingency/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/dblcontingency/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/dblcontingency/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/dblcontingency/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/dblcontingency/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/dblcontingency/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/dblcontingency/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/dblcontingency/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/dblcontingency/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
62/142 files checked 50% done
Checking selforg/simulations/dblcontingency/main.cpp ...
selforg/simulations/dblcontingency/main.cpp:35:5: performance: Variable 'pos' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    pos = initial_pos;
    ^
selforg/simulations/dblcontingency/main.cpp:36:5: performance: Variable 'speed' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    speed = Position(0,0,0);
    ^
selforg/simulations/dblcontingency/main.cpp:100:32: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        i!= otherRobots.end(); i++){
                               ^
63/142 files checked 50% done
Checking selforg/simulations/dblcontingency_direct/cmdline.cpp ...
selforg/simulations/dblcontingency_direct/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
64/142 files checked 51% done
Checking selforg/simulations/dblcontingency_direct/console.cpp ...
selforg/simulations/dblcontingency_direct/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/dblcontingency_direct/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/dblcontingency_direct/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/dblcontingency_direct/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/dblcontingency_direct/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/dblcontingency_direct/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/dblcontingency_direct/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/dblcontingency_direct/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/dblcontingency_direct/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/dblcontingency_direct/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/dblcontingency_direct/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/dblcontingency_direct/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency_direct/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/dblcontingency_direct/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency_direct/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/dblcontingency_direct/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/dblcontingency_direct/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/dblcontingency_direct/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency_direct/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/dblcontingency_direct/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/dblcontingency_direct/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
65/142 files checked 52% done
Checking selforg/simulations/dblcontingency_direct/main.cpp ...
selforg/simulations/dblcontingency_direct/main.cpp:192:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      j++;
      ^
66/142 files checked 52% done
Checking selforg/simulations/interaction_sims/flocks/cmdline.cpp ...
selforg/simulations/interaction_sims/flocks/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
67/142 files checked 52% done
Checking selforg/simulations/interaction_sims/flocks/console.cpp ...
selforg/simulations/interaction_sims/flocks/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/flocks/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/interaction_sims/flocks/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/interaction_sims/flocks/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/interaction_sims/flocks/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/interaction_sims/flocks/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/flocks/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/interaction_sims/flocks/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/flocks/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/flocks/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/interaction_sims/flocks/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/interaction_sims/flocks/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/flocks/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/flocks/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/flocks/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/flocks/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/flocks/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/flocks/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/flocks/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/flocks/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/flocks/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
68/142 files checked 54% done
Checking selforg/simulations/interaction_sims/flocks/main.cpp ...
selforg/simulations/interaction_sims/flocks/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/flocks/main.cpp:59:3: warning: Member variable 'MyRobot::whatDoISee' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, AbstractController* controller, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/flocks/main.cpp:67:5: performance: Variable 'pos' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    pos = initial_pos;
    ^
selforg/simulations/interaction_sims/flocks/main.cpp:68:5: performance: Variable 'speed' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    speed = Position(0,0,0);
    ^
selforg/simulations/interaction_sims/flocks/main.cpp:159:7: warning: Either the condition 'controller' is redundant or there is possible null pointer dereference: controller. [nullPointerRedundantCheck]
      controller->setMotorTeachingSignal(neighboraction.unsafeGetData(),
      ^
selforg/simulations/interaction_sims/flocks/main.cpp:156:8: note: Assuming that condition 'controller' is not redundant
    if(controller && whatDoISee>0)
       ^
selforg/simulations/interaction_sims/flocks/main.cpp:159:7: note: Null pointer dereference
      controller->setMotorTeachingSignal(neighboraction.unsafeGetData(),
      ^
selforg/simulations/interaction_sims/flocks/main.cpp:264:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/flocks/main.cpp:262:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/flocks/main.cpp:264:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/flocks/main.cpp:267:14: style: Variable 'r' can be declared as pointer to const [constVariablePointer]
    MyRobot* r = (MyRobot*) (*i)->getRobot();
             ^
selforg/simulations/interaction_sims/flocks/main.cpp:294:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
69/142 files checked 55% done
Checking selforg/simulations/interaction_sims/interaction/cmdline.cpp ...
selforg/simulations/interaction_sims/interaction/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
70/142 files checked 55% done
Checking selforg/simulations/interaction_sims/interaction/console.cpp ...
selforg/simulations/interaction_sims/interaction/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/interaction_sims/interaction/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/interaction_sims/interaction/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/interaction_sims/interaction/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/interaction_sims/interaction/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/interaction/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/interaction_sims/interaction/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/interaction/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/interaction_sims/interaction/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/interaction_sims/interaction/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/interaction/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/interaction/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/interaction/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/interaction/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/interaction/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
71/142 files checked 56% done
Checking selforg/simulations/interaction_sims/interaction/main.cpp ...
selforg/simulations/interaction_sims/interaction/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction/main.cpp:53:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction/main.cpp:59:5: performance: Variable 'pos' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    pos = initial_pos;
    ^
selforg/simulations/interaction_sims/interaction/main.cpp:60:5: performance: Variable 'speed' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    speed = Position(0,0,0);
    ^
selforg/simulations/interaction_sims/interaction/main.cpp:279:16: style: C-style pointer casting [cstyleCast]
  MyRobot* r = (MyRobot*)a->getRobot();
               ^
selforg/simulations/interaction_sims/interaction/main.cpp:246:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction/main.cpp:244:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction/main.cpp:246:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction/main.cpp:136:18: style: Local variable 'shadow' shadows outer variable [shadowVariable]
        Position shadow = toEnv(opos + Position(shadowdist,shadowdist,0));
                 ^
selforg/simulations/interaction_sims/interaction/main.cpp:28:12: note: Shadowed declaration
const bool shadow = true;
           ^
selforg/simulations/interaction_sims/interaction/main.cpp:136:18: note: Shadow variable
        Position shadow = toEnv(opos + Position(shadowdist,shadowdist,0));
                 ^
selforg/simulations/interaction_sims/interaction/main.cpp:193:12: style: Local variable 'x' shadows outer variable [shadowVariable]
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/interaction/main.cpp:204:11: note: Shadowed declaration
  double* x;
          ^
selforg/simulations/interaction_sims/interaction/main.cpp:193:12: note: Shadow variable
    double x = dist/range;
           ^
72/142 files checked 57% done
Checking selforg/simulations/interaction_sims/interaction1D/cmdline.cpp ...
selforg/simulations/interaction_sims/interaction1D/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
73/142 files checked 57% done
Checking selforg/simulations/interaction_sims/interaction1D/console.cpp ...
selforg/simulations/interaction_sims/interaction1D/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction1D/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/interaction1D/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
74/142 files checked 58% done
Checking selforg/simulations/interaction_sims/interaction1D/main.cpp ...
selforg/simulations/interaction_sims/interaction1D/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction1D/main.cpp:81:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:81:3: warning: Member variable 'MyRobot::mindist' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:304:16: style: C-style pointer casting [cstyleCast]
  MyRobot* r = (MyRobot*)a->getRobot();
               ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:284:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:282:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:284:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:292:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:290:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:292:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:304:12: style: Variable 'r' can be declared as pointer to const [constVariablePointer]
  MyRobot* r = (MyRobot*)a->getRobot();
           ^
selforg/simulations/interaction_sims/interaction1D/main.cpp:380:7: style: Variable 'bg' can be declared as const array [constVariable]
  int bg[bgsize] = {1,1,1,1,1,1,1,0,0,
      ^
75/142 files checked 59% done
Checking selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp ...
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:63:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:145:6: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
    k=10;
     ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:141:8: note: k is assigned
      k++;
       ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:145:6: note: k is overwritten
    k=10;
     ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:251:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:249:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:251:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:260:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:258:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:260:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:195:12: style: Local variable 'x' shadows outer variable [shadowVariable]
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:215:11: note: Shadowed declaration
  double* x;
          ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:195:12: note: Shadow variable
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:276:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
76/142 files checked 60% done
Checking selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp ...
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:74:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:74:3: warning: Member variable 'MyRobot::mindist' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:276:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:274:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:276:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:284:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:282:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:284:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:295:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:366:7: style: Variable 'bg' can be declared as const array [constVariable]
  int bg[bgsize] = {1,1,1,1,1,1,1,0,0,
      ^
77/142 files checked 61% done
Checking selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp ...
selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp:66:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp:237:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp:235:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp:237:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp:255:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
78/142 files checked 62% done
Checking selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp ...
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:63:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:203:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:201:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:203:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:214:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:285:7: style: Variable 'bg' can be declared as const array [constVariable]
  int bg[bgsize] = {1,1,1,1,1,1,1,0,0,
      ^
79/142 files checked 63% done
Checking selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp ...
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:63:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:145:6: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
    k=10;
     ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:141:8: note: k is assigned
      k++;
       ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:145:6: note: k is overwritten
    k=10;
     ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:251:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:249:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:251:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:260:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:258:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:260:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:195:12: style: Local variable 'x' shadows outer variable [shadowVariable]
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:215:11: note: Shadowed declaration
  double* x;
          ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:195:12: note: Shadow variable
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:276:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
80/142 files checked 64% done
Checking selforg/simulations/interaction_sims/shadoworreal/cmdline.cpp ...
selforg/simulations/interaction_sims/shadoworreal/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
81/142 files checked 64% done
Checking selforg/simulations/interaction_sims/shadoworreal/console.cpp ...
selforg/simulations/interaction_sims/shadoworreal/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/interaction_sims/shadoworreal/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
82/142 files checked 65% done
Checking selforg/simulations/interaction_sims/shadoworreal/main.cpp ...
selforg/simulations/interaction_sims/shadoworreal/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:55:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:55:3: warning: Member variable 'MyRobot::real_dist' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:61:5: performance: Variable 'pos' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    pos = initial_pos;
    ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:62:5: performance: Variable 'speed' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    speed = Position(0,0,0);
    ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:268:16: style: C-style pointer casting [cstyleCast]
  MyRobot* r = (MyRobot*)a->getRobot();
               ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:242:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:240:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:242:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:191:12: style: Local variable 'x' shadows outer variable [shadowVariable]
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:205:11: note: Shadowed declaration
  double* x;
          ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:191:12: note: Shadow variable
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:268:12: style: Variable 'r' can be declared as pointer to const [constVariablePointer]
  MyRobot* r = (MyRobot*)a->getRobot();
           ^
83/142 files checked 66% done
Checking selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp ...
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:49:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:55:5: performance: Variable 'pos' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    pos = initial_pos;
    ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:56:5: performance: Variable 'speed' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    speed = Position(0,0,0);
    ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:239:16: style: C-style pointer casting [cstyleCast]
  MyRobot* r = (MyRobot*)a->getRobot();
               ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:219:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:217:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:219:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:172:12: style: Local variable 'x' shadows outer variable [shadowVariable]
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:183:11: note: Shadowed declaration
  double* x;
          ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:172:12: note: Shadow variable
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:239:12: style: Variable 'r' can be declared as pointer to const [constVariablePointer]
  MyRobot* r = (MyRobot*)a->getRobot();
           ^
84/142 files checked 67% done
Checking selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp ...
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:49:3: warning: Member variable 'MyRobot::whatDoIFeel' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:49:3: warning: Member variable 'MyRobot::real_dist' is not initialized in the constructor. [uninitMemberVar]
  MyRobot(const string& name, const Position& initial_pos, double _mass = 1.0)
  ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:55:5: performance: Variable 'pos' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    pos = initial_pos;
    ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:56:5: performance: Variable 'speed' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    speed = Position(0,0,0);
    ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:257:16: style: C-style pointer casting [cstyleCast]
  MyRobot* r = (MyRobot*)a->getRobot();
               ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:233:4: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
  k=0;
   ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:231:6: note: k is assigned
    k++;
     ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:233:4: note: k is overwritten
  k=0;
   ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:185:12: style: Local variable 'x' shadows outer variable [shadowVariable]
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:196:11: note: Shadowed declaration
  double* x;
          ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:185:12: note: Shadow variable
    double x = dist/range;
           ^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:257:12: style: Variable 'r' can be declared as pointer to const [constVariablePointer]
  MyRobot* r = (MyRobot*)a->getRobot();
           ^
85/142 files checked 68% done
Checking selforg/simulations/manipuexperts/cmdline.cpp ...
selforg/simulations/manipuexperts/cmdline.cpp:10:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
86/142 files checked 68% done
Checking selforg/simulations/manipuexperts/console.cpp ...
selforg/simulations/manipuexperts/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/manipuexperts/console.cpp:153:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/manipuexperts/console.cpp:100:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/manipuexperts/console.cpp:235:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/manipuexperts/console.cpp:294:4: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]
  i=0;
   ^
selforg/simulations/manipuexperts/console.cpp:291:6: note: i is assigned
    i++;
     ^
selforg/simulations/manipuexperts/console.cpp:294:4: note: i is overwritten
  i=0;
   ^
selforg/simulations/manipuexperts/console.cpp:284:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/manipuexperts/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/manipuexperts/console.cpp:284:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/manipuexperts/console.cpp:302:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/manipuexperts/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/manipuexperts/console.cpp:302:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/manipuexperts/console.cpp:415:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/manipuexperts/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/manipuexperts/console.cpp:415:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/manipuexperts/console.cpp:421:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/manipuexperts/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/manipuexperts/console.cpp:421:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/manipuexperts/console.cpp:168:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/manipuexperts/console.cpp:170:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/manipuexperts/console.cpp:252:9: style: Variable 'name' can be declared as pointer to const [constVariablePointer]
  char *name;
        ^
selforg/simulations/manipuexperts/console.cpp:302:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/manipuexperts/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/manipuexperts/console.cpp:302:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/manipuexperts/console.cpp:421:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/manipuexperts/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/manipuexperts/console.cpp:421:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/manipuexperts/console.cpp:421:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/manipuexperts/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/manipuexperts/console.cpp:421:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/manipuexperts/console.cpp:462:24: style: Parameter 'caller' can be declared as pointer to const [constParameterPointer]
valid_argument ( char *caller, char *arg)
                       ^
selforg/simulations/manipuexperts/console.cpp:462:38: style: Parameter 'arg' can be declared as pointer to const [constParameterPointer]
valid_argument ( char *caller, char *arg)
                                     ^
selforg/simulations/manipuexperts/console.cpp:85:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
87/142 files checked 69% done
Checking selforg/simulations/manipuexperts/main.cpp ...
selforg/simulations/manipuexperts/main.cpp:43:3: warning: Member variable 'Sim::mep' is not initialized in the constructor. [uninitMemberVar]
  Sim(const string& name)
  ^
selforg/simulations/manipuexperts/main.cpp:43:3: warning: Member variable 'Sim::data_size' is not initialized in the constructor. [uninitMemberVar]
  Sim(const string& name)
  ^
selforg/simulations/manipuexperts/main.cpp:43:3: warning: Member variable 'Sim::t' is not initialized in the constructor. [uninitMemberVar]
  Sim(const string& name)
  ^
selforg/simulations/manipuexperts/multiexpertsubopt.h:69:3: style: Class 'MultiExpertSubopt' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  MultiExpertSubopt(const MultiExpertSuboptConf& conf = getDefaultConf());
  ^
selforg/simulations/manipuexperts/main.cpp:43:3: style: Class 'Sim' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Sim(const string& name)
  ^
selforg/simulations/manipuexperts/main.cpp:62:13: warning: If memory allocation fails, then there is a possible null pointer dereference: filename [nullPointerOutOfMemory]
    f=fopen(filename, "r");
            ^
selforg/simulations/manipuexperts/main.cpp:284:22: note: Assuming allocation function fails
    filename = strdup(argv[index]);
                     ^
selforg/simulations/manipuexperts/main.cpp:284:22: note: Assignment 'filename=strdup(argv[index])', assigned value is 0
    filename = strdup(argv[index]);
                     ^
selforg/simulations/manipuexperts/main.cpp:291:31: note: Calling function 'init', 1st argument 'filename' value is 0
  AbstractModel* m = sim.init(filename);
                              ^
selforg/simulations/manipuexperts/main.cpp:62:13: note: Null pointer dereference
    f=fopen(filename, "r");
            ^
selforg/simulations/manipuexperts/main.cpp:238:40: style: Parameter 'plotoptions' can be declared as reference to const [constParameterReference]
void openPlotOptions(list<PlotOption>& plotoptions , list<const Inspectable*>& inspectables, const vector<Configurable*>& configureables){
                                       ^
selforg/simulations/manipuexperts/main.cpp:258:29: style: Parameter 'plotoptions' can be declared as reference to const [constParameterReference]
void plot(list<PlotOption>& plotoptions, list<const Inspectable*>& inspectables, int t){
                            ^
selforg/simulations/manipuexperts/main.cpp:269:9: style: Variable 'filename' can be declared as pointer to const [constVariablePointer]
  char* filename = "input.dat";
        ^
88/142 files checked 70% done
Checking selforg/simulations/manipuexperts/multiexpertpair.cpp ...
selforg/simulations/manipuexperts/multiexpertpair.cpp:34:18: warning: Member variable 'MultiExpertPair::inputDim' is not initialized in the constructor. [uninitMemberVar]
MultiExpertPair::MultiExpertPair( const MultiExpertPairConf& _conf)
                 ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:34:18: warning: Member variable 'MultiExpertPair::outputDim' is not initialized in the constructor. [uninitMemberVar]
MultiExpertPair::MultiExpertPair( const MultiExpertPairConf& _conf)
                 ^
selforg/simulations/manipuexperts/multiexpertpair.h:59:3: style: Class 'MultiExpertPair' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  MultiExpertPair(const MultiExpertPairConf& conf = getDefaultConf());
  ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:285:3: portability: %i in format string (no. 1) requires 'int' but the argument type is 'std::size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  fprintf(f,"%i\n", sats.size());
  ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:311:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:313:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:242:20: style: C-style pointer casting [cstyleCast]
  return std::min(*(double*)m,d);
                   ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:359:9: style: Checking if unsigned expression 'sats.size()' is less than zero. [unsignedLessThanZero]
    if(i>= sats.size()) return;
        ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:357:18: note: Assignment 'i=0', assigned value is 0
  unsigned int i=0;
                 ^
selforg/simulations/manipuexperts/multiexpertpair.cpp:359:9: note: Unsigned less than zero
    if(i>= sats.size()) return;
        ^
89/142 files checked 71% done
Checking selforg/simulations/manipuexperts/multiexpertsubopt.cpp ...
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:36:20: warning: Member variable 'MultiExpertSubopt::inputDim' is not initialized in the constructor. [uninitMemberVar]
MultiExpertSubopt::MultiExpertSubopt( const MultiExpertSuboptConf& _conf)
                   ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:36:20: warning: Member variable 'MultiExpertSubopt::outputDim' is not initialized in the constructor. [uninitMemberVar]
MultiExpertSubopt::MultiExpertSubopt( const MultiExpertSuboptConf& _conf)
                   ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:36:20: warning: Member variable 'MultiExpertSubopt::t' is not initialized in the constructor. [uninitMemberVar]
MultiExpertSubopt::MultiExpertSubopt( const MultiExpertSuboptConf& _conf)
                   ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:248:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:250:6: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  if(fscanf(f,"%s\n", buffer) != 1) return false;
     ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:165:31: style: C-style pointer casting [cstyleCast]
  MultiExpertSuboptConf* c = (MultiExpertSuboptConf*)conf;
                              ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:298:9: style: Checking if unsigned expression 'sats.size()' is less than zero. [unsignedLessThanZero]
    if(i>= sats.size()) return;
        ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:296:18: note: Assignment 'i=0', assigned value is 0
  unsigned int i=0;
                 ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:298:9: note: Unsigned less than zero
    if(i>= sats.size()) return;
        ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:165:26: style: Variable 'c' can be declared as pointer to const [constVariablePointer]
  MultiExpertSuboptConf* c = (MultiExpertSuboptConf*)conf;
                         ^
selforg/simulations/manipuexperts/multiexpertsubopt.cpp:151:11: warning: Unnecessary comparison of static strings. [staticStringCompare]
    assert("" == "Not implemented version");
          ^
90/142 files checked 72% done
Checking selforg/simulations/pendulum/cmdline.cpp ...
selforg/simulations/pendulum/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
91/142 files checked 72% done
Checking selforg/simulations/pendulum/console.cpp ...
selforg/simulations/pendulum/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/pendulum/console.cpp:153:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/pendulum/console.cpp:100:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/pendulum/console.cpp:235:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/pendulum/console.cpp:294:4: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]
  i=0;
   ^
selforg/simulations/pendulum/console.cpp:291:6: note: i is assigned
    i++;
     ^
selforg/simulations/pendulum/console.cpp:294:4: note: i is overwritten
  i=0;
   ^
selforg/simulations/pendulum/console.cpp:284:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/pendulum/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/pendulum/console.cpp:284:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/pendulum/console.cpp:302:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/pendulum/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/pendulum/console.cpp:302:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/pendulum/console.cpp:415:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/pendulum/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/pendulum/console.cpp:415:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/pendulum/console.cpp:421:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/pendulum/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/pendulum/console.cpp:421:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/pendulum/console.cpp:168:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/pendulum/console.cpp:170:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/pendulum/console.cpp:252:9: style: Variable 'name' can be declared as pointer to const [constVariablePointer]
  char *name;
        ^
selforg/simulations/pendulum/console.cpp:302:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/pendulum/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/pendulum/console.cpp:302:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/pendulum/console.cpp:421:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/pendulum/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/pendulum/console.cpp:421:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/pendulum/console.cpp:421:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/pendulum/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/pendulum/console.cpp:421:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/pendulum/console.cpp:462:24: style: Parameter 'caller' can be declared as pointer to const [constParameterPointer]
valid_argument ( char *caller, char *arg)
                       ^
selforg/simulations/pendulum/console.cpp:462:38: style: Parameter 'arg' can be declared as pointer to const [constParameterPointer]
valid_argument ( char *caller, char *arg)
                                     ^
selforg/simulations/pendulum/console.cpp:85:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
92/142 files checked 73% done
Checking selforg/simulations/pendulum/main.cpp ...
selforg/simulations/pendulum/main.cpp:18:0: information: Include file: "multisat.h" not found. [missingInclude]
#include "multisat.h"
^
selforg/simulations/pendulum/main.cpp:23:0: information: Include file: "pendulum.h" not found. [missingInclude]
#include "pendulum.h"
^
selforg/simulations/pendulum/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/pendulum/main.cpp:30:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
93/142 files checked 74% done
Checking selforg/simulations/pendulum/main_starttop.cpp ...
selforg/simulations/pendulum/main_starttop.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/pendulum/main_starttop.cpp:52:3: style: Class 'Pendulum' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Pendulum(const string& name, double dt = 0.01)
  ^
selforg/simulations/pendulum/main_starttop.cpp:83:29: style: C-style pointer casting [cstyleCast]
    const Pendulum* pendl = (Pendulum*) p;
                            ^
selforg/simulations/pendulum/main_starttop.cpp:188:28: style: Parameter 'robot' can be declared as pointer to const [constParameterPointer]
void printRobots(Pendulum* robot){
                           ^
selforg/simulations/pendulum/main_starttop.cpp:223:23: style: Parameter 'a' can be declared as pointer to const [constParameterPointer]
void reinforce(Agent* a){
                      ^
94/142 files checked 74% done
Checking selforg/simulations/simplesystems/cmdline.cpp ...
selforg/simulations/simplesystems/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
95/142 files checked 74% done
Checking selforg/simulations/simplesystems/console.cpp ...
selforg/simulations/simplesystems/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/simplesystems/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/simplesystems/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/simplesystems/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/simplesystems/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/simplesystems/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/simplesystems/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/simplesystems/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/simplesystems/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/simplesystems/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/simplesystems/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/simplesystems/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/simplesystems/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/simplesystems/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/simplesystems/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/simplesystems/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/simplesystems/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/simplesystems/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/simplesystems/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/simplesystems/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/simplesystems/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/simplesystems/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/simplesystems/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/simplesystems/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/simplesystems/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/simplesystems/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/simplesystems/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/simplesystems/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
96/142 files checked 76% done
Checking selforg/simulations/simplesystems/main.cpp ...
selforg/simulations/simplesystems/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/simplesystems/main.cpp:108:13: style: Variable 'x_cur' can be declared as pointer to const [constVariablePointer]
    double* x_cur = x_buffer[(t-d + buffersize)%buffersize];
            ^
97/142 files checked 77% done
Checking selforg/simulations/spherical_xbee/commtest/main.cpp ...
selforg/simulations/spherical_xbee/commtest/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/spherical_xbee/commtest/main.cpp:24:18: style: Variable 'verboseMode' is assigned a value that is never used. [unreadVariable]
  int verboseMode=0;
                 ^
selforg/simulations/spherical_xbee/commtest/main.cpp:28:46: style: Variable 'verboseMode' is assigned a value that is never used. [unreadVariable]
  if(contains(argv,argc,"-v")!=0) verboseMode=1;
                                             ^
selforg/simulations/spherical_xbee/commtest/main.cpp:29:47: style: Variable 'verboseMode' is assigned a value that is never used. [unreadVariable]
  if(contains(argv,argc,"-vv")!=0) verboseMode=2;
                                              ^
98/142 files checked 77% done
Checking selforg/simulations/spherical_xbee/commtest/serial_unix.cpp ...
selforg/simulations/spherical_xbee/commtest/serial_unix.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/spherical_xbee/commtest/serial_unix.cpp:468:14: style: C-style pointer casting [cstyleCast]
  bool rv = ((CSerialThread*)p)->run();
             ^
selforg/simulations/spherical_xbee/commtest/serial_unix.cpp:158:13: style: Local variable 'b' shadows outer variable [shadowVariable]
        int b =readB();
            ^
selforg/simulations/spherical_xbee/commtest/serial_unix.cpp:145:9: note: Shadowed declaration
    int b;
        ^
selforg/simulations/spherical_xbee/commtest/serial_unix.cpp:158:13: note: Shadow variable
        int b =readB();
            ^
99/142 files checked 78% done
Checking selforg/simulations/spherical_xbee/workstation/cmdline.cpp ...
selforg/simulations/spherical_xbee/workstation/cmdline.cpp:10:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
selforg/simulations/spherical_xbee/workstation/cmdline.cpp:35:69: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    for(ConfigList::iterator i=configs.begin(); i != configs.end(); i++){
                                                                    ^
selforg/simulations/spherical_xbee/workstation/cmdline.cpp:46:58: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(string::const_iterator i=str.begin(); i<str.end(); i++){
                                                         ^
selforg/simulations/spherical_xbee/workstation/cmdline.cpp:53:11: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
          i++;
          ^
100/142 files checked 78% done
Checking selforg/simulations/spherical_xbee/workstation/console.cpp ...
selforg/simulations/spherical_xbee/workstation/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/spherical_xbee/workstation/console.cpp:153:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/spherical_xbee/workstation/console.cpp:100:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/spherical_xbee/workstation/console.cpp:235:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/spherical_xbee/workstation/console.cpp:284:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/spherical_xbee/workstation/console.cpp:284:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:302:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/spherical_xbee/workstation/console.cpp:302:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:415:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/spherical_xbee/workstation/console.cpp:415:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:421:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/spherical_xbee/workstation/console.cpp:421:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/spherical_xbee/workstation/console.cpp:168:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/spherical_xbee/workstation/console.cpp:170:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/spherical_xbee/workstation/console.cpp:252:9: style: Variable 'name' can be declared as pointer to const [constVariablePointer]
  char *name;
        ^
selforg/simulations/spherical_xbee/workstation/console.cpp:302:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/spherical_xbee/workstation/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/spherical_xbee/workstation/console.cpp:302:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/spherical_xbee/workstation/console.cpp:421:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/spherical_xbee/workstation/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/spherical_xbee/workstation/console.cpp:421:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/spherical_xbee/workstation/console.cpp:421:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/spherical_xbee/workstation/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/spherical_xbee/workstation/console.cpp:421:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/spherical_xbee/workstation/console.cpp:462:24: style: Parameter 'caller' can be declared as pointer to const [constParameterPointer]
valid_argument ( char *caller, char *arg)
                       ^
selforg/simulations/spherical_xbee/workstation/console.cpp:462:38: style: Parameter 'arg' can be declared as pointer to const [constParameterPointer]
valid_argument ( char *caller, char *arg)
                                     ^
selforg/simulations/spherical_xbee/workstation/console.cpp:85:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
101/142 files checked 79% done
Checking selforg/simulations/spherical_xbee/workstation/main.cpp ...
selforg/simulations/spherical_xbee/workstation/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/spherical_xbee/workstation/main.cpp:36:3: warning: Member variable 'Xbee::numsensors' is not initialized in the constructor. [uninitMemberVar]
  Xbee(short addr) : addr(addr), initialised(false), failurecounter(0){}
  ^
selforg/simulations/spherical_xbee/workstation/main.cpp:36:3: warning: Member variable 'Xbee::sensoroffset' is not initialized in the constructor. [uninitMemberVar]
  Xbee(short addr) : addr(addr), initialised(false), failurecounter(0){}
  ^
selforg/simulations/spherical_xbee/workstation/main.cpp:36:3: warning: Member variable 'Xbee::nummotors' is not initialized in the constructor. [uninitMemberVar]
  Xbee(short addr) : addr(addr), initialised(false), failurecounter(0){}
  ^
selforg/simulations/spherical_xbee/workstation/main.cpp:36:3: warning: Member variable 'Xbee::motoroffset' is not initialized in the constructor. [uninitMemberVar]
  Xbee(short addr) : addr(addr), initialised(false), failurecounter(0){}
  ^
selforg/simulations/spherical_xbee/workstation/main.cpp:36:3: style: Struct 'Xbee' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Xbee(short addr) : addr(addr), initialised(false), failurecounter(0){}
  ^
selforg/simulations/spherical_xbee/workstation/main.cpp:460:3: style: Class 'OurWiring' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  OurWiring(NoiseGenerator* noise, const std::string& name = "OurWiring")
  ^
selforg/simulations/spherical_xbee/workstation/main.cpp:99:4: style: The destructor '~Communicator' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  ~Communicator(){
   ^
selforg/simulations/spherical_xbee/workstation/serial_unix.h:41:12: note: Virtual destructor in base class
  virtual ~CSerialThread(){stopandwait();};
           ^
selforg/simulations/spherical_xbee/workstation/main.cpp:99:4: note: Destructor in derived class
  ~Communicator(){
   ^
selforg/simulations/spherical_xbee/workstation/main.cpp:180:16: style: The function 'Initialise' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void Initialise(){
               ^
selforg/simulations/spherical_xbee/workstation/serial_unix.h:60:16: note: Virtual function in base class
  virtual void Initialise()  = 0;
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:180:16: note: Function in derived class
  virtual void Initialise(){
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:228:16: style: The function 'writeMotors_readSensors' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void writeMotors_readSensors() {
               ^
selforg/simulations/spherical_xbee/workstation/serial_unix.h:55:16: note: Virtual function in base class
  virtual void writeMotors_readSensors()  = 0; //const DAT& s) = 0;
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:228:16: note: Function in derived class
  virtual void writeMotors_readSensors() {
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:322:16: style: The function 'loopCallback' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void loopCallback(){
               ^
selforg/simulations/spherical_xbee/workstation/serial_unix.h:58:16: note: Virtual function in base class
  virtual void loopCallback()  = 0;
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:322:16: note: Function in derived class
  virtual void loopCallback(){
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:341:13: style: Condition 'pause' is always true [knownConditionTrueFalse]
      while(pause){
            ^
selforg/simulations/spherical_xbee/workstation/main.cpp:325:8: note: Assuming that condition '!pause' is not redundant
    if(!pause){
       ^
selforg/simulations/spherical_xbee/workstation/main.cpp:341:13: note: Condition 'pause' is always true
      while(pause){
            ^
selforg/simulations/spherical_xbee/workstation/main.cpp:336:13: portability: %li in format string (no. 1) requires 'long' but the argument type is 'int {aka signed int}'. [invalidPrintfArgType_sint]
            printf("Time leak of %li ms detected\n",abs(diff));
            ^
selforg/simulations/spherical_xbee/workstation/main.cpp:415:7: style: C-style pointer casting [cstyleCast]
    x=(double*)malloc(sizeof(double)*sensornumber);
      ^
selforg/simulations/spherical_xbee/workstation/main.cpp:416:7: style: C-style pointer casting [cstyleCast]
    y=(double*)malloc(sizeof(double)*motornumber);
      ^
selforg/simulations/spherical_xbee/workstation/main.cpp:477:18: style: C-style pointer casting [cstyleCast]
    lastmotors = (motor*)malloc(sizeof(motor)* rmotornumber);
                 ^
selforg/simulations/spherical_xbee/workstation/main.cpp:229:12: style: The scope of the variable 'len' can be reduced. [variableScope]
    int i, len, offset, n;
           ^
selforg/simulations/spherical_xbee/workstation/main.cpp:229:17: style: The scope of the variable 'offset' can be reduced. [variableScope]
    int i, len, offset, n;
                ^
selforg/simulations/spherical_xbee/workstation/main.cpp:229:25: style: The scope of the variable 'n' can be reduced. [variableScope]
    int i, len, offset, n;
                        ^
selforg/simulations/spherical_xbee/workstation/main.cpp:241:16: style: Local variable 'i' shadows outer variable [shadowVariable]
      for (int i = 0; i < motornumber; i++)
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:229:9: note: Shadowed declaration
    int i, len, offset, n;
        ^
selforg/simulations/spherical_xbee/workstation/main.cpp:241:16: note: Shadow variable
      for (int i = 0; i < motornumber; i++)
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:301:16: style: Local variable 'i' shadows outer variable [shadowVariable]
      for (int i = 0; i < sensornumber; i++)
               ^
selforg/simulations/spherical_xbee/workstation/main.cpp:229:9: note: Shadowed declaration
    int i, len, offset, n;
        ^
selforg/simulations/spherical_xbee/workstation/main.cpp:301:16: note: Shadow variable
      for (int i = 0; i < sensornumber; i++)
               ^
102/142 files checked 81% done
Checking selforg/simulations/spherical_xbee/workstation/serial_unix.cpp ...
selforg/simulations/spherical_xbee/workstation/serial_unix.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/spherical_xbee/workstation/serial_unix.cpp:195:14: style: C-style pointer casting [cstyleCast]
  bool rv = ((CSerialThread*)p)->run();
             ^
selforg/simulations/spherical_xbee/workstation/serial_unix.cpp:179:11: style: Local variable 'b' shadows outer variable [shadowVariable]
      int b =getByte();
          ^
selforg/simulations/spherical_xbee/workstation/serial_unix.cpp:164:7: note: Shadowed declaration
  int b;
      ^
selforg/simulations/spherical_xbee/workstation/serial_unix.cpp:179:11: note: Shadow variable
      int b =getByte();
          ^
103/142 files checked 81% done
Checking selforg/simulations/tcpcommunication/Socket.cpp ...
selforg/simulations/tcpcommunication/Socket.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/tcpcommunication/Socket.cpp:73:9: warning: Member variable 'Socket::_tcpClientSock' is not initialized in the constructor. [uninitMemberVar]
Socket::Socket()
        ^
selforg/simulations/tcpcommunication/Socket.cpp:103:16: style: C-style pointer casting [cstyleCast]
  addr_list = (struct in_addr **)h->h_addr_list;
               ^
selforg/simulations/tcpcommunication/Socket.cpp:117:26: style: C-style pointer casting [cstyleCast]
  if ( ::connect(_sock, (struct sockaddr *) &_peer, sizeof(_peer) ) < 0 ) {
                         ^
selforg/simulations/tcpcommunication/Socket.cpp:122:50: style: C-style pointer casting [cstyleCast]
  if(setsockopt(_sock, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, sizeof(int)) < 0)
                                                 ^
selforg/simulations/tcpcommunication/Socket.cpp:144:26: style: C-style pointer casting [cstyleCast]
  } while(bind(_mysock, (struct sockaddr *) &_peer, sizeof(_peer)) < 0 );
                         ^
selforg/simulations/tcpcommunication/Socket.cpp:156:51: style: C-style pointer casting [cstyleCast]
  if (setsockopt(_sock, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, sizeof(int)) < 0)
                                                  ^
selforg/simulations/tcpcommunication/Socket.cpp:161:52: style: C-style pointer casting [cstyleCast]
  if(setsockopt(_mysock, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, sizeof(int)) < 0)
                                                   ^
selforg/simulations/tcpcommunication/Socket.cpp:207:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__check(b.label, type[0]);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:214:8: style: C-style pointer casting [cstyleCast]
      ((Socket*)this)->__coneverToInt(sizeBytes, &size);
       ^
selforg/simulations/tcpcommunication/Socket.cpp:219:8: style: C-style pointer casting [cstyleCast]
      ((Socket*)this)->__coneverToInt(sizeBytes, &size);
       ^
selforg/simulations/tcpcommunication/Socket.cpp:225:8: style: C-style pointer casting [cstyleCast]
      ((Socket*)this)->__coneverToInt(sizeBytes, &size);
       ^
selforg/simulations/tcpcommunication/Socket.cpp:266:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__writeDouble(&b, d);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:282:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__readDouble(&d, b, 0);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:304:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__writeInteger(&b, i);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:320:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__readInteger(&i, b, 0);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:342:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__writeInteger(&b, (int)s.length());
   ^
selforg/simulations/tcpcommunication/Socket.cpp:363:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__readInteger(&size, b, 0);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:390:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__writeInteger(&b, s);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:395:6: style: C-style pointer casting [cstyleCast]
    ((Socket*)this)->__writeInteger(&b, value);
     ^
selforg/simulations/tcpcommunication/Socket.cpp:415:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__readInteger(&vectorSize, b, 0);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:420:6: style: C-style pointer casting [cstyleCast]
    ((Socket*)this)->__readInteger(&value, b, (i+1) * sizeof(int));
     ^
selforg/simulations/tcpcommunication/Socket.cpp:446:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__writeInteger(&b, s);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:451:6: style: C-style pointer casting [cstyleCast]
    ((Socket*)this)->__writeDouble(&b, value);
     ^
selforg/simulations/tcpcommunication/Socket.cpp:472:4: style: C-style pointer casting [cstyleCast]
  ((Socket*)this)->__readInteger(&vectorSize, b, 0);
   ^
selforg/simulations/tcpcommunication/Socket.cpp:477:6: style: C-style pointer casting [cstyleCast]
    ((Socket*)this)->__readDouble(&value, b, i * sizeof(double) + sizeof(int));
     ^
selforg/simulations/tcpcommunication/Socket.cpp:201:7: style: The scope of the variable 'r' can be reduced. [variableScope]
  int r        = 0;
      ^
selforg/simulations/tcpcommunication/Socket.cpp:204:7: style: The scope of the variable 'toread' can be reduced. [variableScope]
  int toread   = 0;
      ^
selforg/simulations/tcpcommunication/Socket.cpp:532:35: style: Parameter 'c' can be declared as pointer to const [constParameterPointer]
void Socket::__coneverToInt(char *c, int *i)
                                  ^
selforg/simulations/tcpcommunication/Socket.cpp:392:64: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<int>::const_iterator i = v.begin(); i != v.end(); i++)
                                                               ^
selforg/simulations/tcpcommunication/Socket.cpp:448:67: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<double>::const_iterator i = v.begin(); i != v.end(); i++)
                                                                  ^
104/142 files checked 82% done
Checking selforg/simulations/tcpcommunication/clienttest.cpp ...
105/142 files checked 82% done
Checking selforg/simulations/tcpcommunication/cmdline.cpp ...
selforg/simulations/tcpcommunication/cmdline.cpp:11:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
106/142 files checked 82% done
Checking selforg/simulations/tcpcommunication/console.cpp ...
selforg/simulations/tcpcommunication/console.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/tcpcommunication/console.cpp:151:7: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
      return (-1);
      ^
selforg/simulations/tcpcommunication/console.cpp:98:7: style: C-style pointer casting [cstyleCast]
  r = (char*)malloc (strlen (s) + 1);
      ^
selforg/simulations/tcpcommunication/console.cpp:233:13: style: C-style pointer casting [cstyleCast]
  matches = (char **)NULL;
            ^
selforg/simulations/tcpcommunication/console.cpp:282:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_list' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/tcpcommunication/console.cpp:65:13: note: You might need to cast the function pointer here
  { "ls",   com_list, "Synonym for `list'" },
            ^
selforg/simulations/tcpcommunication/console.cpp:282:28: note: Parameter 'globalData' can be declared as reference to const
bool com_list (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/tcpcommunication/console.cpp:300:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_show' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/tcpcommunication/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/tcpcommunication/console.cpp:300:28: note: Parameter 'globalData' can be declared as reference to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/tcpcommunication/console.cpp:413:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_quit' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/tcpcommunication/console.cpp:71:13: note: You might need to cast the function pointer here
  { "quit", com_quit, "Quit program" },
            ^
selforg/simulations/tcpcommunication/console.cpp:413:28: note: Parameter 'globalData' can be declared as reference to const
bool com_quit (GlobalData& globalData, char *, char *){
                           ^
selforg/simulations/tcpcommunication/console.cpp:419:28: style: Parameter 'globalData' can be declared as reference to const. However it seems that 'com_help' is a callback function, if 'globalData' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/tcpcommunication/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/tcpcommunication/console.cpp:419:28: note: Parameter 'globalData' can be declared as reference to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                           ^
selforg/simulations/tcpcommunication/console.cpp:166:30: style: Parameter 'name' can be declared as pointer to const [constParameterPointer]
COMMAND *find_command (char *name){
                             ^
selforg/simulations/tcpcommunication/console.cpp:168:9: style: Variable 'p' can be declared as pointer to const [constVariablePointer]
  char *p = strchr(name,'=');
        ^
selforg/simulations/tcpcommunication/console.cpp:300:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_show' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/tcpcommunication/console.cpp:70:13: note: You might need to cast the function pointer here
  { "view", com_show, "Synonym for `show'" },
            ^
selforg/simulations/tcpcommunication/console.cpp:300:58: note: Parameter 'arg' can be declared as pointer to const
bool com_show (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/tcpcommunication/console.cpp:419:46: style: Parameter 'line' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'line' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/tcpcommunication/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/tcpcommunication/console.cpp:419:46: note: Parameter 'line' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                             ^
selforg/simulations/tcpcommunication/console.cpp:419:58: style: Parameter 'arg' can be declared as pointer to const. However it seems that 'com_help' is a callback function, if 'arg' is declared with const you might also need to cast function pointer(s). [constParameterCallback]
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/tcpcommunication/console.cpp:63:14: note: You might need to cast the function pointer here
  { "?",     com_help, "Synonym for `help'" },
             ^
selforg/simulations/tcpcommunication/console.cpp:419:58: note: Parameter 'arg' can be declared as pointer to const
bool com_help (GlobalData& globalData, char* line, char* arg) {
                                                         ^
selforg/simulations/tcpcommunication/console.cpp:83:84: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(vector<Configurable*>::const_iterator i=configs.begin(); i != configs.end(); i++){
                                                                                   ^
107/142 files checked 84% done
Checking selforg/simulations/tcpcommunication/main.cpp ...
selforg/simulations/tcpcommunication/main.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/simulations/tcpcommunication/tcpcontroller.h:47:3: style: Class 'TcpController' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  TcpController(const string& robotname, int port = 4000, AbstractController* teacher = 0);
  ^
selforg/simulations/tcpcommunication/main.cpp:110:13: style: Variable 'x_cur' can be declared as pointer to const [constVariablePointer]
    double* x_cur = x_buffer[(t-d + buffersize)%buffersize];
            ^
108/142 files checked 85% done
Checking selforg/simulations/tcpcommunication/tcpcontroller.cpp ...
109/142 files checked 85% done
Checking selforg/statistictools/dataanalysation/templatevalueanalysation.cpp ...
selforg/statistictools/dataanalysation/templatevalueanalysation.h:169:9: style: Class 'TemplateValueAnalysation' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TemplateValueAnalysation(std::vector<type>& values) : m_vector(values), m_list(), m_listCreated(false) {}
        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:547:17: style: Struct 'TYPE_SAVE' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
                TYPE_SAVE(type& a) : pointer(&a) {}
                ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:444:27: style: Condition 'iter!=m_list.end()' is always true [knownConditionTrueFalse]
                while(iter!=m_list.end()) {                                                                        //count all element which are higher than W3
                          ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:482:27: style: Condition 'iter!=m_list.end()' is always true [knownConditionTrueFalse]
                while(iter!=m_list.end()) {                                                                                        //search in upper area
                          ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:380:30: warning: Possible dereference of an invalid iterator: iter [derefInvalidIterator]
                while(lower((*iter->pointer),dBorder) && iter!=m_list.end()) {                //search
                             ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:406:30: warning: Possible dereference of an invalid iterator: iter [derefInvalidIterator]
                while(lower((*iter->pointer),dBorder) && iter!=m_list.end()) {                //search
                             ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:431:30: warning: Possible dereference of an invalid iterator: iter [derefInvalidIterator]
                while(lower((*iter->pointer),dW1) && iter!=m_list.end()) {        //count all elements which are lower than W1
                             ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:438:32: warning: Possible dereference of an invalid iterator: iter [derefInvalidIterator]
                while(!higher((*iter->pointer),dW3) && iter!=m_list.end()) {        //go from W1 to W3
                               ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:465:30: warning: Possible dereference of an invalid iterator: iter [derefInvalidIterator]
                while(lower((*iter->pointer),dW1) && iter!=m_list.end()) {                        //search in lower area
                             ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:476:32: warning: Possible dereference of an invalid iterator: iter [derefInvalidIterator]
                while(!higher((*iter->pointer),dW3) && iter!=m_list.end()) {                //go from W1 to W3
                               ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:510:30: warning: Possible dereference of an invalid iterator: iter [derefInvalidIterator]
                while(lower((*iter->pointer),z) && iter!=m_list.end()) {        //search the element which is as first higher than zero
                             ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:186:70: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                for(iter = m_vector.begin(); iter != m_vector.end(); iter++) {
                                                                     ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:207:21: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                for(iter++; iter != m_vector.end(); iter++) {
                    ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:225:21: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                for(iter++; iter != m_vector.end(); iter++) {
                    ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:262:36: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                for(x=0;x<num;x++) iter++;
                                   ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:266:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter--;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:294:36: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                for(x=0;x<num;x++) iter++;
                                   ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:298:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter--;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:325:36: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                for(x=0;x<num;x++) iter++;                                //go to the upper quartil
                                   ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:329:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter--;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:381:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:407:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:413:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter--;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:432:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:439:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:445:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:471:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:477:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:488:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:511:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter++;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:521:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter--;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:527:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        iter--;
                        ^
selforg/statistictools/dataanalysation/templatevalueanalysation.h:577:70: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                for(iter = m_vector.begin(); iter != m_vector.end(); iter++) {                        //fill the sorted list with elements of the help structur
                                                                     ^
110/142 files checked 85% done
Checking selforg/statistictools/measure/complexmeasure.cpp ...
selforg/matrix/sparsearray.h:84:63: portability: Assigning an integer to a pointer is not portable. [AssignmentIntegerToAddress]
      inline D& operator= (ArrayElement& el2)           { this=el2.value; }
                                                              ^
selforg/matrix/sparsearray.h:84:59: error: Found an exit path from function with non-void return type that has missing return statement [missingReturn]
      inline D& operator= (ArrayElement& el2)           { this=el2.value; }
                                                          ^
selforg/statistictools/measure/complexmeasure.cpp:161:42: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
    dS = (- val * log(val)) + ((val+1) * log(val+1));
                                         ^
selforg/statistictools/measure/complexmeasure.cpp:35:17: warning: Member variable 'ComplexMeasure::fSize' is not initialized in the constructor. [uninitMemberVar]
ComplexMeasure::ComplexMeasure( const char* measureName, ComplexMeasureMode mode, int numberBins ) : AbstractMeasure( measureName ), mode( mode ), numberBins( numberBins ), historyIndexList(0), F(0)
                ^
selforg/statistictools/measure/complexmeasure.cpp:35:17: warning: Member variable 'ComplexMeasure::historyIndexNumber' is not initialized in the constructor. [uninitMemberVar]
ComplexMeasure::ComplexMeasure( const char* measureName, ComplexMeasureMode mode, int numberBins ) : AbstractMeasure( measureName ), mode( mode ), numberBins( numberBins ), historyIndexList(0), F(0)
                ^
selforg/statistictools/measure/complexmeasure.cpp:35:17: warning: Member variable 'ComplexMeasure::historyInterval' is not initialized in the constructor. [uninitMemberVar]
ComplexMeasure::ComplexMeasure( const char* measureName, ComplexMeasureMode mode, int numberBins ) : AbstractMeasure( measureName ), mode( mode ), numberBins( numberBins ), historyIndexList(0), F(0)
                ^
selforg/matrix/sparsearray.h:84:17: warning: Member variable 'ArrayElement::index' is not assigned a value in 'ArrayElement::operator='. [operatorEqVarError]
      inline D& operator= (ArrayElement& el2)           { this=el2.value; }
                ^
selforg/matrix/sparsearray.h:84:17: warning: Member variable 'ArrayElement::value' is not assigned a value in 'ArrayElement::operator='. [operatorEqVarError]
      inline D& operator= (ArrayElement& el2)           { this=el2.value; }
                ^
selforg/matrix/sparsearray.h:84:17: warning: Member variable 'ArrayElement::hashData' is not assigned a value in 'ArrayElement::operator='. [operatorEqVarError]
      inline D& operator= (ArrayElement& el2)           { this=el2.value; }
                ^
selforg/matrix/sparsearray.h:84:17: warning: Member variable 'ArrayElement::dummy' is not assigned a value in 'ArrayElement::operator='. [operatorEqVarError]
      inline D& operator= (ArrayElement& el2)           { this=el2.value; }
                ^
selforg/matrix/sparsearray.h:150:25: style: Virtual function 'allocate' is called from constructor 'SparseArray < long , int >(long arraySize)' at line 97. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void inline allocate()
                        ^
selforg/matrix/sparsearray.h:97:7: note: Calling allocate
      allocate();
      ^
selforg/matrix/sparsearray.h:150:25: note: allocate is a virtual function
    virtual void inline allocate()
                        ^
selforg/matrix/sparsearray.h:158:25: style: Virtual function 'freeData' is called from destructor '~SparseArray < long , int >()' at line 101. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void inline freeData()
                        ^
selforg/matrix/sparsearray.h:101:7: note: Calling freeData
      freeData();
      ^
selforg/matrix/sparsearray.h:158:25: note: freeData is a virtual function
    virtual void inline freeData()
                        ^
selforg/statistictools/measure/abstractmeasure.h:43:3: style: Class 'AbstractMeasure' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  AbstractMeasure(const char* measureName)
  ^
selforg/utils/discretisizer.h:56:5: style: Class 'Discretisizer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Discretisizer(int numberBins);
    ^
selforg/matrix/sparsearray.h:95:5: style: Class 'SparseArray < long , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SparseArray(I arraySize) : arraySize(arraySize), hashData(0)
    ^
selforg/statistictools/measure/abstractmeasure.h:46:12: style: The destructor '~AbstractMeasure' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~AbstractMeasure() {}
           ^
selforg/statistictools/measure/imeasure.h:45:18: note: Virtual destructor in base class
        virtual ~IMeasure() {};
                 ^
selforg/statistictools/measure/abstractmeasure.h:46:12: note: Destructor in derived class
  virtual ~AbstractMeasure() {}
           ^
selforg/statistictools/measure/abstractmeasure.h:49:23: style: The function 'getName' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual std::string getName() const { return name; }
                      ^
selforg/statistictools/measure/imeasure.h:49:29: note: Virtual function in base class
        virtual std::string getName() const = 0;
                            ^
selforg/statistictools/measure/abstractmeasure.h:49:23: note: Function in derived class
  virtual std::string getName() const { return name; }
                      ^
selforg/statistictools/measure/abstractmeasure.h:51:18: style: The function 'getValue' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double getValue() const { return value; }
                 ^
selforg/statistictools/measure/imeasure.h:51:24: note: Virtual function in base class
        virtual double getValue() const = 0;
                       ^
selforg/statistictools/measure/abstractmeasure.h:51:18: note: Function in derived class
  virtual double getValue() const { return value; }
                 ^
selforg/statistictools/measure/abstractmeasure.h:53:19: style: The function 'getValueAddress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double& getValueAddress()  { return value; }
                  ^
selforg/statistictools/measure/imeasure.h:53:25: note: Virtual function in base class
        virtual double& getValueAddress()  = 0;
                        ^
selforg/statistictools/measure/abstractmeasure.h:53:19: note: Function in derived class
  virtual double& getValueAddress()  { return value; }
                  ^
selforg/statistictools/measure/abstractmeasure.h:55:16: style: The function 'setStepSize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void setStepSize(int newStepSize) { stepSize=newStepSize; }
               ^
selforg/statistictools/measure/imeasure.h:55:22: note: Virtual function in base class
        virtual void setStepSize(int newStepSize) = 0;
                     ^
selforg/statistictools/measure/abstractmeasure.h:55:16: note: Function in derived class
  virtual void setStepSize(int newStepSize) { stepSize=newStepSize; }
               ^
selforg/statistictools/measure/abstractmeasure.h:57:15: style: The function 'getStepSize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getStepSize() const { return stepSize; }
              ^
selforg/statistictools/measure/imeasure.h:57:21: note: Virtual function in base class
        virtual int getStepSize() const = 0;
                    ^
selforg/statistictools/measure/abstractmeasure.h:57:15: note: Function in derived class
  virtual int getStepSize() const { return stepSize; }
              ^
selforg/statistictools/measure/abstractmeasure.h:59:16: style: The function 'getActualStep' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual long getActualStep() const { return actualStep; }
               ^
selforg/statistictools/measure/imeasure.h:59:22: note: Virtual function in base class
        virtual long getActualStep() const = 0;
                     ^
selforg/statistictools/measure/abstractmeasure.h:59:16: note: Function in derived class
  virtual long getActualStep() const { return actualStep; }
               ^
selforg/statistictools/measure/complexmeasure.h:76:14: style: The destructor '~ComplexMeasure' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~ComplexMeasure();
             ^
selforg/statistictools/measure/abstractmeasure.h:46:12: note: Virtual destructor in base class
  virtual ~AbstractMeasure() {}
           ^
selforg/statistictools/measure/complexmeasure.h:76:14: note: Destructor in derived class
    virtual ~ComplexMeasure();
             ^
selforg/statistictools/measure/complexmeasure.h:82:18: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void step();
                 ^
selforg/statistictools/measure/imeasure.h:47:22: note: Virtual function in base class
        virtual void step() = 0;
                     ^
selforg/statistictools/measure/complexmeasure.h:82:18: note: Function in derived class
    virtual void step();
                 ^
selforg/matrix/sparsearray.h:92:10: style: Class 'ArrayElement' is unsafe, 'ArrayElement::dummy' can leak by wrong usage. [unsafeClassCanLeak]
      D* dummy;
         ^
selforg/matrix/sparsearray.h:81:10: warning: If memory allocation fails, then there is a possible null pointer dereference: dummy [nullPointerOutOfMemory]
        *dummy = value;
         ^
selforg/matrix/sparsearray.h:78:30: note: Assuming allocation function fails
          dummy = (D*) malloc(sizeof(D));
                             ^
selforg/matrix/sparsearray.h:78:19: note: Assignment 'dummy=(int*)malloc(sizeof(int))', assigned value is 0
          dummy = (D*) malloc(sizeof(D));
                  ^
selforg/matrix/sparsearray.h:81:10: note: Null pointer dereference
        *dummy = value;
         ^
selforg/matrix/sparsearray.h:82:17: warning: If memory allocation fails, then there is a possible null pointer dereference: dummy [nullPointerOutOfMemory]
        return *dummy;
                ^
selforg/matrix/sparsearray.h:78:30: note: Assuming allocation function fails
          dummy = (D*) malloc(sizeof(D));
                             ^
selforg/matrix/sparsearray.h:78:19: note: Assignment 'dummy=(int*)malloc(sizeof(int))', assigned value is 0
          dummy = (D*) malloc(sizeof(D));
                  ^
selforg/matrix/sparsearray.h:82:17: note: Null pointer dereference
        return *dummy;
                ^
selforg/statistictools/measure/complexmeasure.cpp:39:22: style: C-style pointer casting [cstyleCast]
  binNumberHistory = ( int* ) malloc( sizeof( double ) * historySize );
                     ^
selforg/matrix/sparsearray.h:78:19: style: C-style pointer casting [cstyleCast]
          dummy = (D*) malloc(sizeof(D));
                  ^
selforg/matrix/sparsearray.h:68:41: style: Parameter 'el2' can be declared as reference to const [constParameterReference]
      inline D operator+ (ArrayElement& el2)            { return value+el2.value; }
                                        ^
selforg/matrix/sparsearray.h:73:44: style: Parameter 'el2' can be declared as reference to const [constParameterReference]
      inline bool operator> (ArrayElement& el2)         { return value>el2.value; }
                                           ^
selforg/matrix/sparsearray.h:84:42: style: Parameter 'el2' can be declared as reference to const [constParameterReference]
      inline D& operator= (ArrayElement& el2)           { this=el2.value; }
                                         ^
selforg/statistictools/measure/complexmeasure.cpp:69:18: style: Unused variable: binList [unusedVariable]
  std::list<int> binList;
                 ^
selforg/statistictools/measure/complexmeasure.cpp:86:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      di++;
      ^
111/142 files checked 86% done
Checking selforg/statistictools/measure/statisticmeasure.cpp ...
selforg/statistictools/measure/statisticmeasure.h:28:0: information: Include file: "measuremodes.h" not found. [missingInclude]
#include "measuremodes.h"
^
selforg/statistictools/measure/statisticmeasure.cpp:28:0: information: Include file: "assert.h" not found. [missingInclude]
#include "assert.h"
^
selforg/statistictools/measure/statisticmeasure.h:40:12: style: The destructor '~StatisticMeasure' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~StatisticMeasure() {}
           ^
selforg/statistictools/measure/abstractmeasure.h:46:12: note: Virtual destructor in base class
  virtual ~AbstractMeasure() {}
           ^
selforg/statistictools/measure/statisticmeasure.h:40:12: note: Destructor in derived class
  virtual ~StatisticMeasure() {}
           ^
selforg/statistictools/measure/statisticmeasure.h:42:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step();
               ^
selforg/statistictools/measure/imeasure.h:47:22: note: Virtual function in base class
        virtual void step() = 0;
                     ^
selforg/statistictools/measure/statisticmeasure.h:42:16: note: Function in derived class
  virtual void step();
               ^
selforg/statistictools/measure/statisticmeasure.cpp:58:26: style: C-style pointer casting [cstyleCast]
    this->valueHistory = (double*) malloc(sizeof(double) * stepSpan);
                         ^
112/142 files checked 86% done
Checking selforg/statistictools/measure/trackablemeasure.cpp ...
selforg/statistictools/measure/trackablemeasure.cpp:29:19: warning: Member variable 'TrackableMeasure::cmode' is not initialized in the constructor. [uninitMemberVar]
TrackableMeasure::TrackableMeasure(std::list<Trackable*> trackableList,const char* measureName  ,ComplexMeasureMode cmode,std::list<Position> cornerPointList, short dimensions, int numberBins) : ComplexMeasure(measureName,cmode, numberBins) ,trackableList(trackableList)
                  ^
selforg/statistictools/measure/trackablemeasure.h:80:16: style: Virtual function 'addDimension' is called from constructor 'TrackableMeasure(std::list<Trackable*>trackableList,const char*measureName,ComplexMeasureMode cmode,std::list<Position>cornerPointList,short dimensions,int numberBins)' at line 33. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void addDimension(short dim, std::list<Position> cornerPointList);
               ^
selforg/statistictools/measure/trackablemeasure.cpp:33:5: note: Calling addDimension
    addDimension(0, cornerPointList);
    ^
selforg/statistictools/measure/trackablemeasure.h:80:16: note: addDimension is a virtual function
  virtual void addDimension(short dim, std::list<Position> cornerPointList);
               ^
selforg/statistictools/measure/trackablemeasure.h:80:16: style: Virtual function 'addDimension' is called from constructor 'TrackableMeasure(std::list<Trackable*>trackableList,const char*measureName,ComplexMeasureMode cmode,std::list<Position>cornerPointList,short dimensions,int numberBins)' at line 35. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void addDimension(short dim, std::list<Position> cornerPointList);
               ^
selforg/statistictools/measure/trackablemeasure.cpp:35:5: note: Calling addDimension
    addDimension(1, cornerPointList);
    ^
selforg/statistictools/measure/trackablemeasure.h:80:16: note: addDimension is a virtual function
  virtual void addDimension(short dim, std::list<Position> cornerPointList);
               ^
selforg/statistictools/measure/trackablemeasure.h:80:16: style: Virtual function 'addDimension' is called from constructor 'TrackableMeasure(std::list<Trackable*>trackableList,const char*measureName,ComplexMeasureMode cmode,std::list<Position>cornerPointList,short dimensions,int numberBins)' at line 37. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void addDimension(short dim, std::list<Position> cornerPointList);
               ^
selforg/statistictools/measure/trackablemeasure.cpp:37:5: note: Calling addDimension
    addDimension(2, cornerPointList);
    ^
selforg/statistictools/measure/trackablemeasure.h:80:16: note: addDimension is a virtual function
  virtual void addDimension(short dim, std::list<Position> cornerPointList);
               ^
selforg/statistictools/measure/trackablemeasure.h:70:16: style: The function 'step' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void step();
               ^
selforg/statistictools/measure/complexmeasure.h:82:18: note: Virtual function in base class
    virtual void step();
                 ^
selforg/statistictools/measure/trackablemeasure.h:70:16: note: Function in derived class
  virtual void step();
               ^
113/142 files checked 87% done
Checking selforg/statistictools/statistictools.cpp ...
selforg/statistictools/statistictools.h:39:0: information: Include file: "templatevalueanalysation.h" not found. [missingInclude]
#include "templatevalueanalysation.h"
^
selforg/statistictools/statistictools.cpp:25:0: information: Include file: "statisticmeasure.h" not found. [missingInclude]
#include "statisticmeasure.h"
^
selforg/statistictools/statistictools.cpp:26:0: information: Include file: "complexmeasure.h" not found. [missingInclude]
#include "complexmeasure.h"
^
selforg/statistictools/statistictools.h:48:3: style: Class 'StatisticTools' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  StatisticTools(const std::string& name = "StatisticTools") : Inspectable(name), beginMeasureCounter(0) { }
  ^
selforg/statistictools/statistictools.h:135:22: style: The function 'doOnCallBack' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual void doOnCallBack(BackCaller* source, BackCaller::CallbackableType type = BackCaller::DEFAULT_CALLBACKABLE_TYPE);
                     ^
selforg/utils/callbackable.h:54:18: note: Virtual function in base class
    virtual void doOnCallBack(BackCaller* source, BackCaller::CallbackableType type = BackCaller::DEFAULT_CALLBACKABLE_TYPE) = 0;
                 ^
selforg/statistictools/statistictools.h:135:22: note: Function in derived class
        virtual void doOnCallBack(BackCaller* source, BackCaller::CallbackableType type = BackCaller::DEFAULT_CALLBACKABLE_TYPE);
                     ^
selforg/statistictools/statistictools.cpp:34:101: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for (std::list<AbstractMeasure*>::iterator i=activeMeasures.begin();i!=activeMeasures.end();i++) {
                                                                                                    ^
114/142 files checked 87% done
Checking selforg/tests/configurabletest.cpp ...
selforg/tests/configurabletest.cpp:104:1: error: There is an unknown macro here somewhere. Configuration is required. If UNIT_TEST_RUN is a macro then please configure it. [unknownMacro]
UNIT_TEST_RUN( "Configurable Tests" )
^
Checking selforg/tests/configurabletest.cpp: UNITTEST...
selforg/tests/unit_test.hpp:171:5: warning: %li in format string (no. 1) requires 'long' but the argument type is 'unsigned long'. [invalidPrintfArgType_sint]
    printf("(%li x):  %7.3f seconds CPU time\n", transactions, run_time );
    ^
115/142 files checked 87% done
Checking selforg/utils/backcaller.cpp ...
Checking selforg/utils/backcaller.cpp: WIN32;_WIN32;_WIN64;__CYGWIN__;__MINGW32__;__WIN32;__WIN32__...
selforg/utils/backcaller.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/utils/quickmp.h:363:25: performance: Variable 'barrierEvent1' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
                        barrierEvent1 = NULL;
                        ^
selforg/utils/quickmp.h:364:25: performance: Variable 'barrierEvent2' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
                        barrierEvent2 = NULL;
                        ^
selforg/utils/quickmp.h:940:17: warning: Class 'ParallelTaskManager' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
                mPlatform = new PlatformThreadObjects();
                ^
selforg/utils/quickmp.h:940:17: warning: Class 'ParallelTaskManager' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
                mPlatform = new PlatformThreadObjects();
                ^
selforg/utils/quickmp.h:546:41: style: C-style pointer casting [cstyleCast]
                                        (void*)threadIndex, 0, (unsigned int*)&mPlatform->
                                        ^
selforg/utils/backcaller.cpp:115:5: style: C-style pointer casting [cstyleCast]
    QMP_SHARE(derefList);
    ^
selforg/utils/backcaller.cpp:116:5: style: C-style pointer casting [cstyleCast]
    QMP_SHARE(type);
    ^
selforg/utils/backcaller.cpp:117:5: style: C-style pointer casting [cstyleCast]
    QMP_SHARE(thisCaller);
    ^
selforg/utils/backcaller.cpp:119:7: style: C-style pointer casting [cstyleCast]
      QMP_USE_SHARED(derefList, callbackableListType);
      ^
selforg/utils/backcaller.cpp:120:7: style: C-style pointer casting [cstyleCast]
      QMP_USE_SHARED(type, CallbackableType);
      ^
selforg/utils/backcaller.cpp:121:7: style: C-style pointer casting [cstyleCast]
      QMP_USE_SHARED(thisCaller, BackCaller);
      ^
selforg/utils/backcaller.cpp:119:7: style: Local variable 'derefList' shadows outer variable [shadowVariable]
      QMP_USE_SHARED(derefList, callbackableListType);
      ^
selforg/utils/backcaller.cpp:113:26: note: Shadowed declaration
    callbackableListType derefList = *list; // use dereferenced version to avoid parallel accesses to the pointer (but i guess that the compiler optimises it already)
                         ^
selforg/utils/backcaller.cpp:119:7: note: Shadow variable
      QMP_USE_SHARED(derefList, callbackableListType);
      ^
selforg/utils/backcaller.cpp:121:7: style: Local variable 'thisCaller' shadows outer variable [shadowVariable]
      QMP_USE_SHARED(thisCaller, BackCaller);
      ^
selforg/utils/backcaller.cpp:114:16: note: Shadowed declaration
    BackCaller thisCaller = *this;
               ^
selforg/utils/backcaller.cpp:121:7: note: Shadow variable
      QMP_USE_SHARED(thisCaller, BackCaller);
      ^
Checking selforg/utils/backcaller.cpp: __APPLE__...
selforg/utils/quickmp.h:583:75: style: C-style pointer casting [cstyleCast]
                                        &threadAttributes, threadRoutine, (void*)threadIndex);
                                                                          ^
selforg/utils/quickmp.h:1059:37: style: Local variable 'returnCode' shadows outer variable [shadowVariable]
                                int returnCode = pthread_mutex_destroy(mPlatform->userMutexes.back());
                                    ^
selforg/utils/quickmp.h:1048:29: note: Shadowed declaration
                        int returnCode = pthread_mutex_destroy(&mPlatform->barrierMutex);
                            ^
selforg/utils/quickmp.h:1059:37: note: Shadow variable
                                int returnCode = pthread_mutex_destroy(mPlatform->userMutexes.back());
                                    ^
Checking selforg/utils/backcaller.cpp: __unix;__unix__;unix...
116/142 files checked 88% done
Checking selforg/utils/configurable.cpp ...
selforg/utils/configurable.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/utils/configurable.cpp:385:18: style: C-style pointer casting [cstyleCast]
  char* buffer = (char*)malloc(sizeof(char)*512);
                 ^
selforg/utils/configurable.cpp:39:8: style: Local variable 'name' shadows outer variable [shadowVariable]
  char name[256];
       ^
selforg/utils/configurable.h:408:14: note: Shadowed declaration
    paramkey name;
             ^
selforg/utils/configurable.cpp:39:8: note: Shadow variable
  char name[256];
       ^
selforg/utils/configurable.cpp:54:8: style: Local variable 'name' shadows outer variable [shadowVariable]
  char name[256];
       ^
selforg/utils/configurable.h:408:14: note: Shadowed declaration
    paramkey name;
             ^
selforg/utils/configurable.cpp:54:8: note: Shadow variable
  char name[256];
       ^
selforg/utils/configurable.cpp:264:39: performance: Searching before insertion is not necessary. Instead of 'mapOfValBounds[key]=std::pair<double,double>(minBound,maxBound)' consider using 'mapOfValBounds.try_emplace(key, std::pair<double,double>(minBound,maxBound));'. [stlFindInsert]
    mapOfValBounds[key]=paramvalBounds(minBound,maxBound);
                                      ^
selforg/utils/configurable.cpp:275:39: performance: Searching before insertion is not necessary. Instead of 'mapOfIntBounds[key]=std::pair<int,int>(minBound,maxBound)' consider using 'mapOfIntBounds.try_emplace(key, std::pair<int,int>(minBound,maxBound));'. [stlFindInsert]
    mapOfIntBounds[key]=paramintBounds(minBound,maxBound);
                                      ^
117/142 files checked 89% done
Checking selforg/utils/configurablelist.cpp ...
selforg/utils/configurablelist.h:41:14: style: The destructor '~ConfigurableList' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~ConfigurableList();
             ^
selforg/utils/backcaller.h:54:14: note: Virtual destructor in base class
    virtual ~BackCaller();
             ^
selforg/utils/configurablelist.h:41:14: note: Destructor in derived class
    virtual ~ConfigurableList();
             ^
118/142 files checked 89% done
Checking selforg/utils/controller_misc.cpp ...
selforg/utils/controller_misc.cpp:18:18: style: C-style pointer casting [cstyleCast]
  return pow(x,*((double*) c));
                 ^
selforg/utils/controller_misc.cpp:33:17: style: C-style pointer casting [cstyleCast]
  RandGen* g = (RandGen*) r;
                ^
selforg/utils/controller_misc.cpp:44:15: style: C-style pointer casting [cstyleCast]
  return x < *(double*)(theta) ? 0 : x;
              ^
selforg/utils/controller_misc.cpp:48:17: style: C-style pointer casting [cstyleCast]
  RandGen* g = (RandGen*) r;
                ^
selforg/utils/controller_misc.cpp:148:26: style: C-style pointer casting [cstyleCast]
      keylist[written] = (char*) malloc(keyLen);
                         ^
selforg/utils/controller_misc.cpp:155:24: style: C-style pointer casting [cstyleCast]
    keylist[written] = (char*) malloc(keyLen);
                       ^
selforg/utils/controller_misc.cpp:198:26: style: C-style pointer casting [cstyleCast]
      keylist[written] = (char*) malloc(keyLen);
                         ^
selforg/utils/controller_misc.cpp:214:26: style: C-style pointer casting [cstyleCast]
      keylist[written] = (char*) malloc(keyLen);
                         ^
selforg/utils/controller_misc.cpp:229:10: style: C-style pointer casting [cstyleCast]
  ng.add((D*) noise, fabs(strength));
         ^
selforg/utils/controller_misc.cpp:236:22: style: C-style pointer casting [cstyleCast]
    long int* seed = (long int*)&num;
                     ^
selforg/utils/controller_misc.cpp:236:22: portability: Casting from double * to signed long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    long int* seed = (long int*)&num;
                     ^
selforg/utils/controller_misc.cpp:17:20: style: Parameter 'c' can be declared as pointer to const [constParameterPointer]
double power(void* c, double x){
                   ^
selforg/utils/controller_misc.cpp:236:15: style: Variable 'seed' can be declared as pointer to const [constVariablePointer]
    long int* seed = (long int*)&num;
              ^
119/142 files checked 90% done
Checking selforg/utils/discretisizer.cpp ...
selforg/utils/discretisizer.cpp:28:16: warning: Member variable 'Discretisizer::minRange' is not initialized in the constructor. [uninitMemberVar]
Discretisizer::Discretisizer(int numberBins) : numberBins(numberBins) {
               ^
selforg/utils/discretisizer.cpp:28:16: warning: Member variable 'Discretisizer::maxRange' is not initialized in the constructor. [uninitMemberVar]
Discretisizer::Discretisizer(int numberBins) : numberBins(numberBins) {
               ^
selforg/utils/discretisizer.cpp:28:16: warning: Member variable 'Discretisizer::minValue' is not initialized in the constructor. [uninitMemberVar]
Discretisizer::Discretisizer(int numberBins) : numberBins(numberBins) {
               ^
selforg/utils/discretisizer.cpp:28:16: warning: Member variable 'Discretisizer::maxValue' is not initialized in the constructor. [uninitMemberVar]
Discretisizer::Discretisizer(int numberBins) : numberBins(numberBins) {
               ^
selforg/utils/discretisizer.cpp:35:16: warning: Member variable 'Discretisizer::minValue' is not initialized in the constructor. [uninitMemberVar]
Discretisizer::Discretisizer(int numberBins, double minRange, double maxRange, bool mapToInterval) : numberBins(numberBins), minRange(minRange), maxRange(maxRange), mapToInterval(mapToInterval) {
               ^
selforg/utils/discretisizer.cpp:35:16: warning: Member variable 'Discretisizer::maxValue' is not initialized in the constructor. [uninitMemberVar]
Discretisizer::Discretisizer(int numberBins, double minRange, double maxRange, bool mapToInterval) : numberBins(numberBins), minRange(minRange), maxRange(maxRange), mapToInterval(mapToInterval) {
               ^
120/142 files checked 91% done
Checking selforg/utils/globaldatabase.cpp ...
Checking selforg/utils/globaldatabase.cpp: NOCONFIGURATOR...
121/142 files checked 91% done
Checking selforg/utils/inspectable.cpp ...
selforg/utils/inspectable.cpp:30:14: warning: Member variable 'Inspectable::printParentName' is not initialized in the constructor. [uninitMemberVar]
Inspectable::Inspectable(const iparamkey& name) : name(name), parent(0) {}
             ^
122/142 files checked 91% done
Checking selforg/utils/inspectableproxy.cpp ...
selforg/utils/inspectableproxy.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/utils/inspectableproxy.h:44:9: style: Class 'InspectableProxy' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        InspectableProxy(const std::list<Inspectable*>& list, const iparamkey& name = "InspectableProxy");
        ^
selforg/utils/inspectableproxy.h:68:9: style: Class 'InspectableProxy' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        InspectableProxy(const iparamkey& name = "InspectableProxy");
        ^
selforg/utils/inspectableproxy.h:49:18: style: The destructor '~InspectableProxy' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual ~InspectableProxy();
                 ^
selforg/utils/inspectable.h:110:12: note: Virtual destructor in base class
  virtual ~Inspectable();
           ^
selforg/utils/inspectableproxy.h:49:18: note: Destructor in derived class
        virtual ~InspectableProxy();
                 ^
selforg/utils/inspectableproxy.cpp:34:92: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for(std::list<Inspectable*>::const_iterator iter = list.begin(); iter!=list.end(); iter++) {
                                                                                           ^
selforg/utils/inspectableproxy.cpp:44:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        namesIter++;
                        ^
selforg/utils/inspectableproxy.cpp:45:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        valuesIter++;
                        ^
selforg/utils/inspectableproxy.cpp:108:25: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                        l++;
                        ^
123/142 files checked 92% done
Checking selforg/utils/lyapunov.cpp ...
124/142 files checked 92% done
Checking selforg/utils/mediator.cpp ...
selforg/utils/mediator.cpp:45:57: style: Parameter 'collegue' can be declared as pointer to const [constParameterPointer]
void Mediator::removeMediatorCollegue(MediatorCollegue *collegue)
                                                        ^
selforg/utils/mediator.cpp:63:67: style: Parameter 'collegue' can be declared as pointer to const [constParameterPointer]
unsigned int Mediator::getMediatorCollegueIndex(MediatorCollegue* collegue)
                                                                  ^
125/142 files checked 92% done
Checking selforg/utils/mediatorcollegue.cpp ...
126/142 files checked 93% done
Checking selforg/utils/parametrizable.cpp ...
selforg/utils/parametrizable.cpp:57:30: style: Parameter 'pld' can be declared as reference to const [constParameterReference]
void assignPL(ParameterList& pld, const ParameterList& pls){
                             ^
selforg/utils/parametrizable.cpp:42:9: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
    res.push_back(fun(p));
        ^
selforg/utils/parametrizable.cpp:60:96: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for( ParameterList::iterator pd = pld.begin(), __end1=pld.end(); pd!= __end1 && ps!= __end2; pd++ , ps++)
                                                                                               ^
127/142 files checked 93% done
Checking selforg/utils/plotoption.cpp ...
Checking selforg/utils/plotoption.cpp: WIN32;_WIN32;_WIN64;__CYGWIN__;__MINGW32__;__WIN32;__WIN32__...
selforg/utils/plotoption.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/utils/plotoption.cpp:89:11: style: The if condition is the same as the previous if condition [duplicateCondition]
      if (lpzrobots_home) {
          ^
selforg/utils/plotoption.cpp:85:11: note: First condition
      if (lpzrobots_home) {
          ^
selforg/utils/plotoption.cpp:89:11: note: Second condition
      if (lpzrobots_home) {
          ^
selforg/utils/plotoption.cpp:313:11: portability: %lu in format string (no. 1) requires 'unsigned long' but the argument type is 'std::size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
          fprintf(stderr, "PlotOption: mask to short: %lu <= %i", mask.size(),cnt); // should not happen
          ^
selforg/utils/plotoption.cpp:45:18: style: Local variable 't' shadows outer variable [shadowVariable]
      struct tm *t;
                 ^
selforg/utils/plotoption.h:156:8: note: Shadowed declaration
  long t;
       ^
selforg/utils/plotoption.cpp:45:18: note: Shadow variable
      struct tm *t;
                 ^
selforg/utils/plotoption.cpp:45:18: style: Variable 't' can be declared as pointer to const [constVariablePointer]
      struct tm *t;
                 ^
Checking selforg/utils/plotoption.cpp: __APPLE__...
Checking selforg/utils/plotoption.cpp: __unix;__unix__;unix...
128/142 files checked 94% done
Checking selforg/utils/plotoptionengine.cpp ...
selforg/utils/plotoptionengine.h:62:16: style: Virtual function 'closePipes' is called from destructor '~PlotOptionEngine()' at line 52. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void closePipes();
               ^
selforg/utils/plotoptionengine.cpp:52:3: note: Calling closePipes
  closePipes();
  ^
selforg/utils/plotoptionengine.h:62:16: note: closePipes is a virtual function
  virtual void closePipes();
               ^
selforg/utils/plotoptionengine.cpp:76:12: style: Local variable 't' shadows outer variable [shadowVariable]
    time_t t = time(0);
           ^
selforg/utils/plotoptionengine.h:115:12: note: Shadowed declaration
  long int t;
           ^
selforg/utils/plotoptionengine.cpp:76:12: note: Shadow variable
    time_t t = time(0);
           ^
selforg/utils/plotoptionengine.cpp:198:81: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for(list<PlotOption>::iterator i=plotOptions.begin(); i != plotOptions.end(); i++)
                                                                                ^
Checking selforg/utils/plotoptionengine.cpp: SIGPIPE...
129/142 files checked 95% done
Checking selforg/utils/randomgenerator.cpp ...
selforg/utils/randomgenerator.cpp:69:41: style: Condition '__drand48_iterate(xsubi,buffer)<0' is always false [knownConditionTrueFalse]
  if (__drand48_iterate (xsubi, buffer) < 0)
                                        ^
selforg/utils/randomgenerator.cpp:69:25: note: Calling function '__drand48_iterate' returns 0
  if (__drand48_iterate (xsubi, buffer) < 0)
                        ^
selforg/utils/randomgenerator.cpp:69:41: note: Condition '__drand48_iterate(xsubi,buffer)<0' is always false
  if (__drand48_iterate (xsubi, buffer) < 0)
                                        ^
Checking selforg/utils/randomgenerator.cpp: WIN32...
130/142 files checked 95% done
Checking selforg/utils/stl_adds.cpp ...
131/142 files checked 95% done
Checking selforg/utils/storeable.cpp ...
132/142 files checked 95% done
Checking selforg/utils/trackrobots.cpp ...
selforg/utils/trackrobots.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
133/142 files checked 96% done
Checking selforg/wiredcontroller.cpp ...
selforg/wiredcontroller.cpp:35:0: information: Include file: "abstractwiring.h" not found. [missingInclude]
#include "abstractwiring.h"
^
selforg/wiredcontroller.cpp:101:19: style: C-style pointer casting [cstyleCast]
  csensors      = (sensor*) malloc(sizeof(sensor) * csensornumber);
                  ^
selforg/wiredcontroller.cpp:102:19: style: C-style pointer casting [cstyleCast]
  cmotors       = (motor*)  malloc(sizeof(motor)  * cmotornumber);
                  ^
134/142 files checked 96% done
Checking selforg/wirings/abstractwiring.cpp ...
selforg/wirings/abstractwiring.h:50:3: warning: Member variable 'AbstractWiring::noisenumber' is not initialized in the constructor. [uninitMemberVar]
  AbstractWiring(NoiseGenerator* noise, int plotMode=Controller, const std::string& name = "AbstractWiring")
  ^
selforg/wirings/abstractwiring.h:50:3: warning: Member variable 'AbstractWiring::randGen' is not initialized in the constructor. [uninitMemberVar]
  AbstractWiring(NoiseGenerator* noise, int plotMode=Controller, const std::string& name = "AbstractWiring")
  ^
selforg/wirings/abstractwiring.h:63:12: style: The destructor '~AbstractWiring' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~AbstractWiring(){
           ^
selforg/utils/inspectable.h:110:12: note: Virtual destructor in base class
  virtual ~Inspectable();
           ^
selforg/wirings/abstractwiring.h:63:12: note: Destructor in derived class
  virtual ~AbstractWiring(){
           ^
selforg/wirings/abstractwiring.cpp:39:15: style: C-style pointer casting [cstyleCast]
  noisevals = (double*) mNoise.unsafeGetData(); // hack! we let the noiseval pointer point to the internal memory of the noisematrix.
              ^
selforg/wirings/abstractwiring.cpp:35:17: style: Variable 'noisenumber' is reassigned a value before the old one has been used. [redundantAssignment]
  noisenumber   = rsensornumber;
                ^
selforg/wirings/abstractwiring.cpp:33:17: note: noisenumber is assigned
  noisenumber   = rsensornumber;
                ^
selforg/wirings/abstractwiring.cpp:35:17: note: noisenumber is overwritten
  noisenumber   = rsensornumber;
                ^
135/142 files checked 97% done
Checking selforg/wirings/copywiring.cpp ...
136/142 files checked 97% done
Checking selforg/wirings/derivativewiring.cpp ...
selforg/wirings/derivativewiring.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
selforg/wirings/derivativewiring.cpp:30:19: warning: Member variable 'DerivativeWiring::sensorbuffer' is not initialized in the constructor. [uninitMemberVar]
DerivativeWiring::DerivativeWiring(const DerivativeWiringConf& conf,
                  ^
selforg/wirings/derivativewiring.cpp:61:28: style: C-style pointer casting [cstyleCast]
    sensorbuffer[i]      = (sensor*) malloc(sizeof(sensor) * this->rsensornumber);
                           ^
selforg/wirings/derivativewiring.cpp:67:32: style: C-style pointer casting [cstyleCast]
  if(conf.useFirstD)  first  = (sensor*) malloc(sizeof(sensor) * this->rsensornumber);
                               ^
selforg/wirings/derivativewiring.cpp:68:32: style: C-style pointer casting [cstyleCast]
  if(conf.useSecondD) second = (sensor*) malloc(sizeof(sensor) * this->rsensornumber);
                               ^
selforg/wirings/derivativewiring.cpp:70:25: style: C-style pointer casting [cstyleCast]
    blindMotors       = (motor*) malloc(sizeof(motor) * conf.blindMotors);
                        ^
selforg/wirings/derivativewiring.cpp:183:11: style: Variable 't' can be declared as pointer to const [constVariablePointer]
  sensor* t   = sensorbuffer[time%buffersize];
          ^
selforg/wirings/derivativewiring.cpp:184:11: style: Variable 'tmdelay' can be declared as pointer to const [constVariablePointer]
  sensor* tmdelay = sensorbuffer[(time-1)%buffersize];
          ^
selforg/wirings/derivativewiring.cpp:192:11: style: Variable 't' can be declared as pointer to const [constVariablePointer]
  sensor* t   = sensorbuffer[time%buffersize];
          ^
selforg/wirings/derivativewiring.cpp:193:11: style: Variable 'tmdelay' can be declared as pointer to const [constVariablePointer]
  sensor* tmdelay = sensorbuffer[(time-1)%buffersize];
          ^
selforg/wirings/derivativewiring.cpp:194:11: style: Variable 'tm2delay' can be declared as pointer to const [constVariablePointer]
  sensor* tm2delay = sensorbuffer[(time-2)%buffersize];
          ^
137/142 files checked 98% done
Checking selforg/wirings/feedbackwiring.cpp ...
selforg/wirings/feedbackwiring.h:55:3: style: Class 'FeedbackWiring' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  FeedbackWiring(NoiseGenerator* noise, Mode mode = Context,double feedbackratio=0.9, const std::string& name = "FeedBackWiring");
  ^
selforg/wirings/feedbackwiring.cpp:58:10: warning: If memory allocation fails, then there is a possible null pointer dereference: motors [nullPointerOutOfMemory]
  memset(motors,0,sizeof(motor)  * this->cmotornumber);
         ^
selforg/wirings/feedbackwiring.cpp:57:31: note: Assuming allocation function fails
  motors    = (motor*)  malloc(sizeof(motor)  * this->cmotornumber);
                              ^
selforg/wirings/feedbackwiring.cpp:57:15: note: Assignment 'motors=(double*)malloc(sizeof(double)*this->cmotornumber)', assigned value is 0
  motors    = (motor*)  malloc(sizeof(motor)  * this->cmotornumber);
              ^
selforg/wirings/feedbackwiring.cpp:58:10: note: Null pointer dereference
  memset(motors,0,sizeof(motor)  * this->cmotornumber);
         ^
selforg/wirings/feedbackwiring.cpp:57:15: style: C-style pointer casting [cstyleCast]
  motors    = (motor*)  malloc(sizeof(motor)  * this->cmotornumber);
              ^
138/142 files checked 98% done
Checking selforg/wirings/forceboostwiring.cpp ...
selforg/wirings/forceboostwiring.h:45:3: style: Class 'ForceBoostWiring' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  ForceBoostWiring(NoiseGenerator* noise, double boost=0, bool exportBoostError=false,
  ^
139/142 files checked 98% done
Checking selforg/wirings/one2onewiring.cpp ...
selforg/wirings/one2onewiring.h:40:3: style: Class 'One2OneWiring' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  One2OneWiring(NoiseGenerator* noise, int plotMode=Controller, int blind=0, const std::string& name = "One2OneWiring");
  ^
selforg/wirings/one2onewiring.cpp:49:12: warning: If memory allocation fails, then there is a possible null pointer dereference: blindmotors [nullPointerOutOfMemory]
    memset(blindmotors, 0, sizeof(sensor)  * blind);
           ^
selforg/wirings/one2onewiring.cpp:48:35: note: Assuming allocation function fails
    blindmotors = (sensor*) malloc(sizeof(sensor)  * blind);
                                  ^
selforg/wirings/one2onewiring.cpp:48:19: note: Assignment 'blindmotors=(double*)malloc(sizeof(double)*blind)', assigned value is 0
    blindmotors = (sensor*) malloc(sizeof(sensor)  * blind);
                  ^
selforg/wirings/one2onewiring.cpp:49:12: note: Null pointer dereference
    memset(blindmotors, 0, sizeof(sensor)  * blind);
           ^
selforg/wirings/one2onewiring.cpp:48:19: style: C-style pointer casting [cstyleCast]
    blindmotors = (sensor*) malloc(sizeof(sensor)  * blind);
                  ^
140/142 files checked 99% done
Checking selforg/wirings/selectiveone2onewiring.cpp ...
selforg/wirings/selectiveone2onewiring.h:45:12: style: The destructor '~select_firsthalf' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~select_firsthalf(){}
           ^
selforg/wirings/selectiveone2onewiring.h:38:12: note: Virtual destructor in base class
  virtual ~select_predicate(){}
           ^
selforg/wirings/selectiveone2onewiring.h:45:12: note: Destructor in derived class
  virtual ~select_firsthalf(){}
           ^
selforg/wirings/selectiveone2onewiring.h:46:16: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool operator()( int index,  int len) { return index < len/2; }
               ^
selforg/wirings/selectiveone2onewiring.h:39:16: note: Virtual function in base class
  virtual bool operator()( int index,  int len) { return true; }
               ^
selforg/wirings/selectiveone2onewiring.h:46:16: note: Function in derived class
  virtual bool operator()( int index,  int len) { return index < len/2; }
               ^
selforg/wirings/selectiveone2onewiring.h:51:12: style: The destructor '~select_from_to' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual ~select_from_to(){}
           ^
selforg/wirings/selectiveone2onewiring.h:38:12: note: Virtual destructor in base class
  virtual ~select_predicate(){}
           ^
selforg/wirings/selectiveone2onewiring.h:51:12: note: Destructor in derived class
  virtual ~select_from_to(){}
           ^
selforg/wirings/selectiveone2onewiring.h:53:16: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool operator()( int index,  int len) { return (index >= from) && (index <= to); }
               ^
selforg/wirings/selectiveone2onewiring.h:39:16: note: Virtual function in base class
  virtual bool operator()( int index,  int len) { return true; }
               ^
selforg/wirings/selectiveone2onewiring.h:53:16: note: Function in derived class
  virtual bool operator()( int index,  int len) { return (index >= from) && (index <= to); }
               ^
selforg/wirings/selectiveone2onewiring.h:45:12: style: The destructor '~select_firsthalf' overrides a destructor in a base class but is identical to the overridden function [uselessOverride]
  virtual ~select_firsthalf(){}
           ^
selforg/wirings/selectiveone2onewiring.h:38:12: note: Virtual destructor in base class
  virtual ~select_predicate(){}
           ^
selforg/wirings/selectiveone2onewiring.h:45:12: note: Destructor in derived class
  virtual ~select_firsthalf(){}
           ^
141/142 files checked 99% done
Checking selforg/wirings/wiringsequence.cpp ...
selforg/wirings/wiringsequence.h:59:16: style: Virtual function 'addWiring' is called from constructor 'WiringSequence(AbstractWiring*w1,AbstractWiring*w2)' at line 40. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void addWiring(AbstractWiring* wiring) override;
               ^
selforg/wirings/wiringsequence.cpp:40:3: note: Calling addWiring
  addWiring(w1);
  ^
selforg/wirings/wiringsequence.h:59:16: note: addWiring is a virtual function
  virtual void addWiring(AbstractWiring* wiring) override;
               ^
selforg/wirings/wiringsequence.h:59:16: style: Virtual function 'addWiring' is called from constructor 'WiringSequence(AbstractWiring*w1,AbstractWiring*w2)' at line 41. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void addWiring(AbstractWiring* wiring) override;
               ^
selforg/wirings/wiringsequence.cpp:41:3: note: Calling addWiring
  addWiring(w2);
  ^
selforg/wirings/wiringsequence.h:59:16: note: addWiring is a virtual function
  virtual void addWiring(AbstractWiring* wiring) override;
               ^
selforg/wirings/wiringsequence.h:64:8: warning: The class 'WiringSequence' defines member variable with name 'initialised' also defined in its parent class 'AbstractWiring'. [duplInheritedMember]
  bool initialised;
       ^
selforg/wirings/abstractwiring.h:202:8: note: Parent variable 'AbstractWiring::initialised'
  bool initialised;
       ^
selforg/wirings/wiringsequence.h:64:8: note: Derived variable 'WiringSequence::initialised'
  bool initialised;
       ^
selforg/wirings/wiringsequence.h:38:3: style: Class 'WiringSequence' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  WiringSequence(std::list<AbstractWiring*>);
  ^
142/142 files checked 100% done
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/dblcontingency/main.cpp:27:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/dblcontingency_direct/main.cpp:36:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/flocks/main.cpp:57:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/interaction/main.cpp:51:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/interaction1D/main.cpp:79:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/interaction1D/main_pos_senor.cpp:61:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/interaction1D/main_vision_2agents.cpp:72:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/interaction1D/main_vision_4objects.cpp:64:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/interaction1D/main_vision_bg.cpp:61:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/interaction1D/main_visual_motor.cpp:61:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/shadoworreal/main.cpp:53:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow.cpp:47:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/interaction_sims/shadoworreal/main_real_and_shadow_and_static.cpp:47:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/simulations/dblcontingency/console.cpp:54:9: error: The one definition rule is violated, different classes/structs have the same name 'COMMAND' [ctuOneDefinitionRuleViolation]
typedef struct {
        ^
selforg/simulations/manipuexperts/console.cpp:54:9: note: The one definition rule is violated, different classes/structs have the same name 'COMMAND'
typedef struct {
        ^
selforg/simulations/dblcontingency/console.cpp:54:9: note: The one definition rule is violated, different classes/structs have the same name 'COMMAND'
typedef struct {
        ^
selforg/controller/multireinforce.h:50:9: error: The one definition rule is violated, different classes/structs have the same name 'Sat' [ctuOneDefinitionRuleViolation]
typedef struct Sat {
        ^
selforg/simulations/manipuexperts/multiexpertpair.h:45:9: note: The one definition rule is violated, different classes/structs have the same name 'Sat'
typedef struct Sat {
        ^
selforg/controller/multireinforce.h:50:9: note: The one definition rule is violated, different classes/structs have the same name 'Sat'
typedef struct Sat {
        ^
selforg/simulations/dblcontingency/globaldata.h:38:1: error: The one definition rule is violated, different classes/structs have the same name 'GlobalData' [ctuOneDefinitionRuleViolation]
struct GlobalData
^
selforg/simulations/pendulum/globaldata.h:38:1: note: The one definition rule is violated, different classes/structs have the same name 'GlobalData'
struct GlobalData
^
selforg/simulations/dblcontingency/globaldata.h:38:1: note: The one definition rule is violated, different classes/structs have the same name 'GlobalData'
struct GlobalData
^
selforg/simulations/dblcontingency/console.cpp:54:9: error: The one definition rule is violated, different classes/structs have the same name 'COMMAND' [ctuOneDefinitionRuleViolation]
typedef struct {
        ^
selforg/simulations/pendulum/console.cpp:54:9: note: The one definition rule is violated, different classes/structs have the same name 'COMMAND'
typedef struct {
        ^
selforg/simulations/dblcontingency/console.cpp:54:9: note: The one definition rule is violated, different classes/structs have the same name 'COMMAND'
typedef struct {
        ^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/simplesystems/main.cpp:37:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/simulations/dblcontingency/console.cpp:54:9: error: The one definition rule is violated, different classes/structs have the same name 'COMMAND' [ctuOneDefinitionRuleViolation]
typedef struct {
        ^
selforg/simulations/spherical_xbee/workstation/console.cpp:54:9: note: The one definition rule is violated, different classes/structs have the same name 'COMMAND'
typedef struct {
        ^
selforg/simulations/dblcontingency/console.cpp:54:9: note: The one definition rule is violated, different classes/structs have the same name 'COMMAND'
typedef struct {
        ^
selforg/examples/integration/main.cpp:19:1: error: The one definition rule is violated, different classes/structs have the same name 'MyRobot' [ctuOneDefinitionRuleViolation]
class MyRobot : public AbstractRobot {
^
selforg/simulations/tcpcommunication/main.cpp:39:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
selforg/examples/integration/main.cpp:19:1: note: The one definition rule is violated, different classes/structs have the same name 'MyRobot'
class MyRobot : public AbstractRobot {
^
nofile:0:0: information: Active checkers: There was critical errors (use --checkers-report=<filename> to see details) [checkersReport]

